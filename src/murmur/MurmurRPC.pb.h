// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MurmurRPC.proto

#ifndef PROTOBUF_INCLUDED_MurmurRPC_2eproto
#define PROTOBUF_INCLUDED_MurmurRPC_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_MurmurRPC_2eproto 

namespace protobuf_MurmurRPC_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[55];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_MurmurRPC_2eproto
namespace MurmurRPC {
class ACL;
class ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
class ACL_Group;
class ACL_GroupDefaultTypeInternal;
extern ACL_GroupDefaultTypeInternal _ACL_Group_default_instance_;
class ACL_List;
class ACL_ListDefaultTypeInternal;
extern ACL_ListDefaultTypeInternal _ACL_List_default_instance_;
class ACL_Query;
class ACL_QueryDefaultTypeInternal;
extern ACL_QueryDefaultTypeInternal _ACL_Query_default_instance_;
class ACL_TemporaryGroup;
class ACL_TemporaryGroupDefaultTypeInternal;
extern ACL_TemporaryGroupDefaultTypeInternal _ACL_TemporaryGroup_default_instance_;
class Authenticator;
class AuthenticatorDefaultTypeInternal;
extern AuthenticatorDefaultTypeInternal _Authenticator_default_instance_;
class Authenticator_Request;
class Authenticator_RequestDefaultTypeInternal;
extern Authenticator_RequestDefaultTypeInternal _Authenticator_Request_default_instance_;
class Authenticator_Request_Authenticate;
class Authenticator_Request_AuthenticateDefaultTypeInternal;
extern Authenticator_Request_AuthenticateDefaultTypeInternal _Authenticator_Request_Authenticate_default_instance_;
class Authenticator_Request_Deregister;
class Authenticator_Request_DeregisterDefaultTypeInternal;
extern Authenticator_Request_DeregisterDefaultTypeInternal _Authenticator_Request_Deregister_default_instance_;
class Authenticator_Request_Find;
class Authenticator_Request_FindDefaultTypeInternal;
extern Authenticator_Request_FindDefaultTypeInternal _Authenticator_Request_Find_default_instance_;
class Authenticator_Request_Query;
class Authenticator_Request_QueryDefaultTypeInternal;
extern Authenticator_Request_QueryDefaultTypeInternal _Authenticator_Request_Query_default_instance_;
class Authenticator_Request_Register;
class Authenticator_Request_RegisterDefaultTypeInternal;
extern Authenticator_Request_RegisterDefaultTypeInternal _Authenticator_Request_Register_default_instance_;
class Authenticator_Request_Update;
class Authenticator_Request_UpdateDefaultTypeInternal;
extern Authenticator_Request_UpdateDefaultTypeInternal _Authenticator_Request_Update_default_instance_;
class Authenticator_Response;
class Authenticator_ResponseDefaultTypeInternal;
extern Authenticator_ResponseDefaultTypeInternal _Authenticator_Response_default_instance_;
class Authenticator_Response_Authenticate;
class Authenticator_Response_AuthenticateDefaultTypeInternal;
extern Authenticator_Response_AuthenticateDefaultTypeInternal _Authenticator_Response_Authenticate_default_instance_;
class Authenticator_Response_Deregister;
class Authenticator_Response_DeregisterDefaultTypeInternal;
extern Authenticator_Response_DeregisterDefaultTypeInternal _Authenticator_Response_Deregister_default_instance_;
class Authenticator_Response_Find;
class Authenticator_Response_FindDefaultTypeInternal;
extern Authenticator_Response_FindDefaultTypeInternal _Authenticator_Response_Find_default_instance_;
class Authenticator_Response_Initialize;
class Authenticator_Response_InitializeDefaultTypeInternal;
extern Authenticator_Response_InitializeDefaultTypeInternal _Authenticator_Response_Initialize_default_instance_;
class Authenticator_Response_Query;
class Authenticator_Response_QueryDefaultTypeInternal;
extern Authenticator_Response_QueryDefaultTypeInternal _Authenticator_Response_Query_default_instance_;
class Authenticator_Response_Register;
class Authenticator_Response_RegisterDefaultTypeInternal;
extern Authenticator_Response_RegisterDefaultTypeInternal _Authenticator_Response_Register_default_instance_;
class Authenticator_Response_Update;
class Authenticator_Response_UpdateDefaultTypeInternal;
extern Authenticator_Response_UpdateDefaultTypeInternal _Authenticator_Response_Update_default_instance_;
class Ban;
class BanDefaultTypeInternal;
extern BanDefaultTypeInternal _Ban_default_instance_;
class Ban_List;
class Ban_ListDefaultTypeInternal;
extern Ban_ListDefaultTypeInternal _Ban_List_default_instance_;
class Ban_Query;
class Ban_QueryDefaultTypeInternal;
extern Ban_QueryDefaultTypeInternal _Ban_Query_default_instance_;
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Channel_List;
class Channel_ListDefaultTypeInternal;
extern Channel_ListDefaultTypeInternal _Channel_List_default_instance_;
class Channel_Query;
class Channel_QueryDefaultTypeInternal;
extern Channel_QueryDefaultTypeInternal _Channel_Query_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Config_Field;
class Config_FieldDefaultTypeInternal;
extern Config_FieldDefaultTypeInternal _Config_Field_default_instance_;
class Config_FieldsEntry_DoNotUse;
class Config_FieldsEntry_DoNotUseDefaultTypeInternal;
extern Config_FieldsEntry_DoNotUseDefaultTypeInternal _Config_FieldsEntry_DoNotUse_default_instance_;
class ContextAction;
class ContextActionDefaultTypeInternal;
extern ContextActionDefaultTypeInternal _ContextAction_default_instance_;
class DatabaseUser;
class DatabaseUserDefaultTypeInternal;
extern DatabaseUserDefaultTypeInternal _DatabaseUser_default_instance_;
class DatabaseUser_List;
class DatabaseUser_ListDefaultTypeInternal;
extern DatabaseUser_ListDefaultTypeInternal _DatabaseUser_List_default_instance_;
class DatabaseUser_Query;
class DatabaseUser_QueryDefaultTypeInternal;
extern DatabaseUser_QueryDefaultTypeInternal _DatabaseUser_Query_default_instance_;
class DatabaseUser_Verify;
class DatabaseUser_VerifyDefaultTypeInternal;
extern DatabaseUser_VerifyDefaultTypeInternal _DatabaseUser_Verify_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Log_List;
class Log_ListDefaultTypeInternal;
extern Log_ListDefaultTypeInternal _Log_List_default_instance_;
class Log_Query;
class Log_QueryDefaultTypeInternal;
extern Log_QueryDefaultTypeInternal _Log_Query_default_instance_;
class RedirectWhisperGroup;
class RedirectWhisperGroupDefaultTypeInternal;
extern RedirectWhisperGroupDefaultTypeInternal _RedirectWhisperGroup_default_instance_;
class Server;
class ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_Event;
class Server_EventDefaultTypeInternal;
extern Server_EventDefaultTypeInternal _Server_Event_default_instance_;
class Server_List;
class Server_ListDefaultTypeInternal;
extern Server_ListDefaultTypeInternal _Server_List_default_instance_;
class Server_Query;
class Server_QueryDefaultTypeInternal;
extern Server_QueryDefaultTypeInternal _Server_Query_default_instance_;
class TextMessage;
class TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
class TextMessage_Filter;
class TextMessage_FilterDefaultTypeInternal;
extern TextMessage_FilterDefaultTypeInternal _TextMessage_Filter_default_instance_;
class Tree;
class TreeDefaultTypeInternal;
extern TreeDefaultTypeInternal _Tree_default_instance_;
class Tree_Query;
class Tree_QueryDefaultTypeInternal;
extern Tree_QueryDefaultTypeInternal _Tree_Query_default_instance_;
class Uptime;
class UptimeDefaultTypeInternal;
extern UptimeDefaultTypeInternal _Uptime_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class User_Kick;
class User_KickDefaultTypeInternal;
extern User_KickDefaultTypeInternal _User_Kick_default_instance_;
class User_List;
class User_ListDefaultTypeInternal;
extern User_ListDefaultTypeInternal _User_List_default_instance_;
class User_Query;
class User_QueryDefaultTypeInternal;
extern User_QueryDefaultTypeInternal _User_Query_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace MurmurRPC
namespace google {
namespace protobuf {
template<> ::MurmurRPC::ACL* Arena::CreateMaybeMessage<::MurmurRPC::ACL>(Arena*);
template<> ::MurmurRPC::ACL_Group* Arena::CreateMaybeMessage<::MurmurRPC::ACL_Group>(Arena*);
template<> ::MurmurRPC::ACL_List* Arena::CreateMaybeMessage<::MurmurRPC::ACL_List>(Arena*);
template<> ::MurmurRPC::ACL_Query* Arena::CreateMaybeMessage<::MurmurRPC::ACL_Query>(Arena*);
template<> ::MurmurRPC::ACL_TemporaryGroup* Arena::CreateMaybeMessage<::MurmurRPC::ACL_TemporaryGroup>(Arena*);
template<> ::MurmurRPC::Authenticator* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator>(Arena*);
template<> ::MurmurRPC::Authenticator_Request* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Authenticate* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Authenticate>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Deregister* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Deregister>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Find* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Find>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Query* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Query>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Register* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Register>(Arena*);
template<> ::MurmurRPC::Authenticator_Request_Update* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Update>(Arena*);
template<> ::MurmurRPC::Authenticator_Response* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Authenticate* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Authenticate>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Deregister* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Deregister>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Find* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Find>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Initialize* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Initialize>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Query* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Query>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Register* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Register>(Arena*);
template<> ::MurmurRPC::Authenticator_Response_Update* Arena::CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Update>(Arena*);
template<> ::MurmurRPC::Ban* Arena::CreateMaybeMessage<::MurmurRPC::Ban>(Arena*);
template<> ::MurmurRPC::Ban_List* Arena::CreateMaybeMessage<::MurmurRPC::Ban_List>(Arena*);
template<> ::MurmurRPC::Ban_Query* Arena::CreateMaybeMessage<::MurmurRPC::Ban_Query>(Arena*);
template<> ::MurmurRPC::Channel* Arena::CreateMaybeMessage<::MurmurRPC::Channel>(Arena*);
template<> ::MurmurRPC::Channel_List* Arena::CreateMaybeMessage<::MurmurRPC::Channel_List>(Arena*);
template<> ::MurmurRPC::Channel_Query* Arena::CreateMaybeMessage<::MurmurRPC::Channel_Query>(Arena*);
template<> ::MurmurRPC::Config* Arena::CreateMaybeMessage<::MurmurRPC::Config>(Arena*);
template<> ::MurmurRPC::Config_Field* Arena::CreateMaybeMessage<::MurmurRPC::Config_Field>(Arena*);
template<> ::MurmurRPC::Config_FieldsEntry_DoNotUse* Arena::CreateMaybeMessage<::MurmurRPC::Config_FieldsEntry_DoNotUse>(Arena*);
template<> ::MurmurRPC::ContextAction* Arena::CreateMaybeMessage<::MurmurRPC::ContextAction>(Arena*);
template<> ::MurmurRPC::DatabaseUser* Arena::CreateMaybeMessage<::MurmurRPC::DatabaseUser>(Arena*);
template<> ::MurmurRPC::DatabaseUser_List* Arena::CreateMaybeMessage<::MurmurRPC::DatabaseUser_List>(Arena*);
template<> ::MurmurRPC::DatabaseUser_Query* Arena::CreateMaybeMessage<::MurmurRPC::DatabaseUser_Query>(Arena*);
template<> ::MurmurRPC::DatabaseUser_Verify* Arena::CreateMaybeMessage<::MurmurRPC::DatabaseUser_Verify>(Arena*);
template<> ::MurmurRPC::Event* Arena::CreateMaybeMessage<::MurmurRPC::Event>(Arena*);
template<> ::MurmurRPC::Log* Arena::CreateMaybeMessage<::MurmurRPC::Log>(Arena*);
template<> ::MurmurRPC::Log_List* Arena::CreateMaybeMessage<::MurmurRPC::Log_List>(Arena*);
template<> ::MurmurRPC::Log_Query* Arena::CreateMaybeMessage<::MurmurRPC::Log_Query>(Arena*);
template<> ::MurmurRPC::RedirectWhisperGroup* Arena::CreateMaybeMessage<::MurmurRPC::RedirectWhisperGroup>(Arena*);
template<> ::MurmurRPC::Server* Arena::CreateMaybeMessage<::MurmurRPC::Server>(Arena*);
template<> ::MurmurRPC::Server_Event* Arena::CreateMaybeMessage<::MurmurRPC::Server_Event>(Arena*);
template<> ::MurmurRPC::Server_List* Arena::CreateMaybeMessage<::MurmurRPC::Server_List>(Arena*);
template<> ::MurmurRPC::Server_Query* Arena::CreateMaybeMessage<::MurmurRPC::Server_Query>(Arena*);
template<> ::MurmurRPC::TextMessage* Arena::CreateMaybeMessage<::MurmurRPC::TextMessage>(Arena*);
template<> ::MurmurRPC::TextMessage_Filter* Arena::CreateMaybeMessage<::MurmurRPC::TextMessage_Filter>(Arena*);
template<> ::MurmurRPC::Tree* Arena::CreateMaybeMessage<::MurmurRPC::Tree>(Arena*);
template<> ::MurmurRPC::Tree_Query* Arena::CreateMaybeMessage<::MurmurRPC::Tree_Query>(Arena*);
template<> ::MurmurRPC::Uptime* Arena::CreateMaybeMessage<::MurmurRPC::Uptime>(Arena*);
template<> ::MurmurRPC::User* Arena::CreateMaybeMessage<::MurmurRPC::User>(Arena*);
template<> ::MurmurRPC::User_Kick* Arena::CreateMaybeMessage<::MurmurRPC::User_Kick>(Arena*);
template<> ::MurmurRPC::User_List* Arena::CreateMaybeMessage<::MurmurRPC::User_List>(Arena*);
template<> ::MurmurRPC::User_Query* Arena::CreateMaybeMessage<::MurmurRPC::User_Query>(Arena*);
template<> ::MurmurRPC::Version* Arena::CreateMaybeMessage<::MurmurRPC::Version>(Arena*);
template<> ::MurmurRPC::Void* Arena::CreateMaybeMessage<::MurmurRPC::Void>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace MurmurRPC {

enum Server_Event_Type {
  Server_Event_Type_UserConnected = 0,
  Server_Event_Type_UserDisconnected = 1,
  Server_Event_Type_UserStateChanged = 2,
  Server_Event_Type_UserTextMessage = 3,
  Server_Event_Type_ChannelCreated = 4,
  Server_Event_Type_ChannelRemoved = 5,
  Server_Event_Type_ChannelStateChanged = 6
};
bool Server_Event_Type_IsValid(int value);
const Server_Event_Type Server_Event_Type_Type_MIN = Server_Event_Type_UserConnected;
const Server_Event_Type Server_Event_Type_Type_MAX = Server_Event_Type_ChannelStateChanged;
const int Server_Event_Type_Type_ARRAYSIZE = Server_Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Server_Event_Type_descriptor();
inline const ::std::string& Server_Event_Type_Name(Server_Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Server_Event_Type_descriptor(), value);
}
inline bool Server_Event_Type_Parse(
    const ::std::string& name, Server_Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Server_Event_Type>(
    Server_Event_Type_descriptor(), name, value);
}
enum Event_Type {
  Event_Type_ServerStopped = 0,
  Event_Type_ServerStarted = 1
};
bool Event_Type_IsValid(int value);
const Event_Type Event_Type_Type_MIN = Event_Type_ServerStopped;
const Event_Type Event_Type_Type_MAX = Event_Type_ServerStarted;
const int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor();
inline const ::std::string& Event_Type_Name(Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Type_descriptor(), value);
}
inline bool Event_Type_Parse(
    const ::std::string& name, Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
enum ContextAction_Context {
  ContextAction_Context_Server = 1,
  ContextAction_Context_Channel = 2,
  ContextAction_Context_User = 4
};
bool ContextAction_Context_IsValid(int value);
const ContextAction_Context ContextAction_Context_Context_MIN = ContextAction_Context_Server;
const ContextAction_Context ContextAction_Context_Context_MAX = ContextAction_Context_User;
const int ContextAction_Context_Context_ARRAYSIZE = ContextAction_Context_Context_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextAction_Context_descriptor();
inline const ::std::string& ContextAction_Context_Name(ContextAction_Context value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextAction_Context_descriptor(), value);
}
inline bool ContextAction_Context_Parse(
    const ::std::string& name, ContextAction_Context* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextAction_Context>(
    ContextAction_Context_descriptor(), name, value);
}
enum TextMessage_Filter_Action {
  TextMessage_Filter_Action_Accept = 0,
  TextMessage_Filter_Action_Reject = 1,
  TextMessage_Filter_Action_Drop = 2
};
bool TextMessage_Filter_Action_IsValid(int value);
const TextMessage_Filter_Action TextMessage_Filter_Action_Action_MIN = TextMessage_Filter_Action_Accept;
const TextMessage_Filter_Action TextMessage_Filter_Action_Action_MAX = TextMessage_Filter_Action_Drop;
const int TextMessage_Filter_Action_Action_ARRAYSIZE = TextMessage_Filter_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* TextMessage_Filter_Action_descriptor();
inline const ::std::string& TextMessage_Filter_Action_Name(TextMessage_Filter_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    TextMessage_Filter_Action_descriptor(), value);
}
inline bool TextMessage_Filter_Action_Parse(
    const ::std::string& name, TextMessage_Filter_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextMessage_Filter_Action>(
    TextMessage_Filter_Action_descriptor(), name, value);
}
enum ACL_Permission {
  ACL_Permission_None = 0,
  ACL_Permission_Write = 1,
  ACL_Permission_Traverse = 2,
  ACL_Permission_Enter = 4,
  ACL_Permission_Speak = 8,
  ACL_Permission_Whisper = 256,
  ACL_Permission_MuteDeafen = 16,
  ACL_Permission_Move = 32,
  ACL_Permission_MakeChannel = 64,
  ACL_Permission_MakeTemporaryChannel = 1024,
  ACL_Permission_LinkChannel = 128,
  ACL_Permission_TextMessage = 512,
  ACL_Permission_Kick = 65536,
  ACL_Permission_Ban = 131072,
  ACL_Permission_Register = 262144,
  ACL_Permission_RegisterSelf = 524288
};
bool ACL_Permission_IsValid(int value);
const ACL_Permission ACL_Permission_Permission_MIN = ACL_Permission_None;
const ACL_Permission ACL_Permission_Permission_MAX = ACL_Permission_RegisterSelf;
const int ACL_Permission_Permission_ARRAYSIZE = ACL_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACL_Permission_descriptor();
inline const ::std::string& ACL_Permission_Name(ACL_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACL_Permission_descriptor(), value);
}
inline bool ACL_Permission_Parse(
    const ::std::string& name, ACL_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACL_Permission>(
    ACL_Permission_descriptor(), name, value);
}
enum Authenticator_Response_Status {
  Authenticator_Response_Status_Fallthrough = 0,
  Authenticator_Response_Status_Success = 1,
  Authenticator_Response_Status_Failure = 2,
  Authenticator_Response_Status_TemporaryFailure = 3
};
bool Authenticator_Response_Status_IsValid(int value);
const Authenticator_Response_Status Authenticator_Response_Status_Status_MIN = Authenticator_Response_Status_Fallthrough;
const Authenticator_Response_Status Authenticator_Response_Status_Status_MAX = Authenticator_Response_Status_TemporaryFailure;
const int Authenticator_Response_Status_Status_ARRAYSIZE = Authenticator_Response_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Authenticator_Response_Status_descriptor();
inline const ::std::string& Authenticator_Response_Status_Name(Authenticator_Response_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Authenticator_Response_Status_descriptor(), value);
}
inline bool Authenticator_Response_Status_Parse(
    const ::std::string& name, Authenticator_Response_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Authenticator_Response_Status>(
    Authenticator_Response_Status_descriptor(), name, value);
}
// ===================================================================

class Void : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Void* other);
  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(NULL);
  }

  Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MurmurRPC.Void)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Version : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Version* other);
  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(NULL);
  }

  Version* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string release = 2;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 2;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  #if LANG_CXX11
  void set_release(::std::string&& value);
  #endif
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string os = 3;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 3;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // optional string os_version = 4;
  bool has_os_version() const;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 4;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  #if LANG_CXX11
  void set_os_version(::std::string&& value);
  #endif
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Version)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_release();
  void clear_has_release();
  void set_has_os();
  void clear_has_os();
  void set_has_os_version();
  void clear_has_os_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::uint32 version_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Uptime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Uptime) */ {
 public:
  Uptime();
  virtual ~Uptime();

  Uptime(const Uptime& from);

  inline Uptime& operator=(const Uptime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uptime(Uptime&& from) noexcept
    : Uptime() {
    *this = ::std::move(from);
  }

  inline Uptime& operator=(Uptime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uptime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uptime* internal_default_instance() {
    return reinterpret_cast<const Uptime*>(
               &_Uptime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Uptime* other);
  friend void swap(Uptime& a, Uptime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uptime* New() const final {
    return CreateMaybeMessage<Uptime>(NULL);
  }

  Uptime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Uptime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Uptime& from);
  void MergeFrom(const Uptime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uptime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 secs = 1;
  bool has_secs() const;
  void clear_secs();
  static const int kSecsFieldNumber = 1;
  ::google::protobuf::uint64 secs() const;
  void set_secs(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Uptime)
 private:
  void set_has_secs();
  void clear_has_secs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 secs_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Server_Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Server.Event) */ {
 public:
  Server_Event();
  virtual ~Server_Event();

  Server_Event(const Server_Event& from);

  inline Server_Event& operator=(const Server_Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Server_Event(Server_Event&& from) noexcept
    : Server_Event() {
    *this = ::std::move(from);
  }

  inline Server_Event& operator=(Server_Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Server_Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Server_Event* internal_default_instance() {
    return reinterpret_cast<const Server_Event*>(
               &_Server_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Server_Event* other);
  friend void swap(Server_Event& a, Server_Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Server_Event* New() const final {
    return CreateMaybeMessage<Server_Event>(NULL);
  }

  Server_Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Server_Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Server_Event& from);
  void MergeFrom(const Server_Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_Event_Type Type;
  static const Type UserConnected =
    Server_Event_Type_UserConnected;
  static const Type UserDisconnected =
    Server_Event_Type_UserDisconnected;
  static const Type UserStateChanged =
    Server_Event_Type_UserStateChanged;
  static const Type UserTextMessage =
    Server_Event_Type_UserTextMessage;
  static const Type ChannelCreated =
    Server_Event_Type_ChannelCreated;
  static const Type ChannelRemoved =
    Server_Event_Type_ChannelRemoved;
  static const Type ChannelStateChanged =
    Server_Event_Type_ChannelStateChanged;
  static inline bool Type_IsValid(int value) {
    return Server_Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Server_Event_Type_Type_MIN;
  static const Type Type_MAX =
    Server_Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Server_Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Server_Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Server_Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Server_Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // optional .MurmurRPC.TextMessage message = 4;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  private:
  const ::MurmurRPC::TextMessage& _internal_message() const;
  public:
  const ::MurmurRPC::TextMessage& message() const;
  ::MurmurRPC::TextMessage* release_message();
  ::MurmurRPC::TextMessage* mutable_message();
  void set_allocated_message(::MurmurRPC::TextMessage* message);

  // optional .MurmurRPC.Channel channel = 5;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 5;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // optional .MurmurRPC.Server.Event.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::MurmurRPC::Server_Event_Type type() const;
  void set_type(::MurmurRPC::Server_Event_Type value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Server.Event)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_type();
  void clear_has_type();
  void set_has_user();
  void clear_has_user();
  void set_has_message();
  void clear_has_message();
  void set_has_channel();
  void clear_has_channel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* user_;
  ::MurmurRPC::TextMessage* message_;
  ::MurmurRPC::Channel* channel_;
  int type_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Server_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Server.Query) */ {
 public:
  Server_Query();
  virtual ~Server_Query();

  Server_Query(const Server_Query& from);

  inline Server_Query& operator=(const Server_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Server_Query(Server_Query&& from) noexcept
    : Server_Query() {
    *this = ::std::move(from);
  }

  inline Server_Query& operator=(Server_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Server_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Server_Query* internal_default_instance() {
    return reinterpret_cast<const Server_Query*>(
               &_Server_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Server_Query* other);
  friend void swap(Server_Query& a, Server_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Server_Query* New() const final {
    return CreateMaybeMessage<Server_Query>(NULL);
  }

  Server_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Server_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Server_Query& from);
  void MergeFrom(const Server_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MurmurRPC.Server.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Server_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Server.List) */ {
 public:
  Server_List();
  virtual ~Server_List();

  Server_List(const Server_List& from);

  inline Server_List& operator=(const Server_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Server_List(Server_List&& from) noexcept
    : Server_List() {
    *this = ::std::move(from);
  }

  inline Server_List& operator=(Server_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Server_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Server_List* internal_default_instance() {
    return reinterpret_cast<const Server_List*>(
               &_Server_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Server_List* other);
  friend void swap(Server_List& a, Server_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Server_List* New() const final {
    return CreateMaybeMessage<Server_List>(NULL);
  }

  Server_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Server_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Server_List& from);
  void MergeFrom(const Server_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Server servers = 1;
  int servers_size() const;
  void clear_servers();
  static const int kServersFieldNumber = 1;
  ::MurmurRPC::Server* mutable_servers(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Server >*
      mutable_servers();
  const ::MurmurRPC::Server& servers(int index) const;
  ::MurmurRPC::Server* add_servers();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Server >&
      servers() const;

  // @@protoc_insertion_point(class_scope:MurmurRPC.Server.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Server > servers_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Server : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Server) */ {
 public:
  Server();
  virtual ~Server();

  Server(const Server& from);

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(Server&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Server& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Server* other);
  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Server* New() const final {
    return CreateMaybeMessage<Server>(NULL);
  }

  Server* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Server& from);
  void MergeFrom(const Server& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_Event Event;
  typedef Server_Query Query;
  typedef Server_List List;

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Uptime uptime = 3;
  bool has_uptime() const;
  void clear_uptime();
  static const int kUptimeFieldNumber = 3;
  private:
  const ::MurmurRPC::Uptime& _internal_uptime() const;
  public:
  const ::MurmurRPC::Uptime& uptime() const;
  ::MurmurRPC::Uptime* release_uptime();
  ::MurmurRPC::Uptime* mutable_uptime();
  void set_allocated_uptime(::MurmurRPC::Uptime* uptime);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional bool running = 2;
  bool has_running() const;
  void clear_running();
  static const int kRunningFieldNumber = 2;
  bool running() const;
  void set_running(bool value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Server)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_running();
  void clear_has_running();
  void set_has_uptime();
  void clear_has_uptime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Uptime* uptime_;
  ::google::protobuf::uint32 id_;
  bool running_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_Type Type;
  static const Type ServerStopped =
    Event_Type_ServerStopped;
  static const Type ServerStarted =
    Event_Type_ServerStarted;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Event_Type_Type_MIN;
  static const Type Type_MAX =
    Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Event.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::MurmurRPC::Event_Type type() const;
  void set_type(::MurmurRPC::Event_Type value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Event)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  int type_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ContextAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ContextAction) */ {
 public:
  ContextAction();
  virtual ~ContextAction();

  ContextAction(const ContextAction& from);

  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContextAction(ContextAction&& from) noexcept
    : ContextAction() {
    *this = ::std::move(from);
  }

  inline ContextAction& operator=(ContextAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContextAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContextAction* internal_default_instance() {
    return reinterpret_cast<const ContextAction*>(
               &_ContextAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ContextAction* other);
  friend void swap(ContextAction& a, ContextAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContextAction* New() const final {
    return CreateMaybeMessage<ContextAction>(NULL);
  }

  ContextAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContextAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContextAction& from);
  void MergeFrom(const ContextAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ContextAction_Context Context;
  static const Context Server =
    ContextAction_Context_Server;
  static const Context Channel =
    ContextAction_Context_Channel;
  static const Context User =
    ContextAction_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextAction_Context_IsValid(value);
  }
  static const Context Context_MIN =
    ContextAction_Context_Context_MIN;
  static const Context Context_MAX =
    ContextAction_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    ContextAction_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Context_descriptor() {
    return ContextAction_Context_descriptor();
  }
  static inline const ::std::string& Context_Name(Context value) {
    return ContextAction_Context_Name(value);
  }
  static inline bool Context_Parse(const ::std::string& name,
      Context* value) {
    return ContextAction_Context_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string action = 3;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 3;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // optional string text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User actor = 5;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 5;
  private:
  const ::MurmurRPC::User& _internal_actor() const;
  public:
  const ::MurmurRPC::User& actor() const;
  ::MurmurRPC::User* release_actor();
  ::MurmurRPC::User* mutable_actor();
  void set_allocated_actor(::MurmurRPC::User* actor);

  // optional .MurmurRPC.User user = 6;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 6;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // optional .MurmurRPC.Channel channel = 7;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 7;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // optional uint32 context = 2;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 2;
  ::google::protobuf::uint32 context() const;
  void set_context(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ContextAction)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_context();
  void clear_has_context();
  void set_has_action();
  void clear_has_action();
  void set_has_text();
  void clear_has_text();
  void set_has_actor();
  void clear_has_actor();
  void set_has_user();
  void clear_has_user();
  void set_has_channel();
  void clear_has_channel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* actor_;
  ::MurmurRPC::User* user_;
  ::MurmurRPC::Channel* channel_;
  ::google::protobuf::uint32 context_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextMessage_Filter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.TextMessage.Filter) */ {
 public:
  TextMessage_Filter();
  virtual ~TextMessage_Filter();

  TextMessage_Filter(const TextMessage_Filter& from);

  inline TextMessage_Filter& operator=(const TextMessage_Filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextMessage_Filter(TextMessage_Filter&& from) noexcept
    : TextMessage_Filter() {
    *this = ::std::move(from);
  }

  inline TextMessage_Filter& operator=(TextMessage_Filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMessage_Filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextMessage_Filter* internal_default_instance() {
    return reinterpret_cast<const TextMessage_Filter*>(
               &_TextMessage_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TextMessage_Filter* other);
  friend void swap(TextMessage_Filter& a, TextMessage_Filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextMessage_Filter* New() const final {
    return CreateMaybeMessage<TextMessage_Filter>(NULL);
  }

  TextMessage_Filter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextMessage_Filter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextMessage_Filter& from);
  void MergeFrom(const TextMessage_Filter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextMessage_Filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextMessage_Filter_Action Action;
  static const Action Accept =
    TextMessage_Filter_Action_Accept;
  static const Action Reject =
    TextMessage_Filter_Action_Reject;
  static const Action Drop =
    TextMessage_Filter_Action_Drop;
  static inline bool Action_IsValid(int value) {
    return TextMessage_Filter_Action_IsValid(value);
  }
  static const Action Action_MIN =
    TextMessage_Filter_Action_Action_MIN;
  static const Action Action_MAX =
    TextMessage_Filter_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    TextMessage_Filter_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return TextMessage_Filter_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return TextMessage_Filter_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return TextMessage_Filter_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.TextMessage message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  private:
  const ::MurmurRPC::TextMessage& _internal_message() const;
  public:
  const ::MurmurRPC::TextMessage& message() const;
  ::MurmurRPC::TextMessage* release_message();
  ::MurmurRPC::TextMessage* mutable_message();
  void set_allocated_message(::MurmurRPC::TextMessage* message);

  // optional .MurmurRPC.TextMessage.Filter.Action action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::MurmurRPC::TextMessage_Filter_Action action() const;
  void set_action(::MurmurRPC::TextMessage_Filter_Action value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.TextMessage.Filter)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_action();
  void clear_has_action();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::TextMessage* message_;
  int action_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.TextMessage) */ {
 public:
  TextMessage();
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextMessage(TextMessage&& from) noexcept
    : TextMessage() {
    *this = ::std::move(from);
  }

  inline TextMessage& operator=(TextMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextMessage* internal_default_instance() {
    return reinterpret_cast<const TextMessage*>(
               &_TextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(TextMessage* other);
  friend void swap(TextMessage& a, TextMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextMessage* New() const final {
    return CreateMaybeMessage<TextMessage>(NULL);
  }

  TextMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextMessage_Filter Filter;

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.User users = 3;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 3;
  ::MurmurRPC::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
      mutable_users();
  const ::MurmurRPC::User& users(int index) const;
  ::MurmurRPC::User* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
      users() const;

  // repeated .MurmurRPC.Channel channels = 4;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 4;
  ::MurmurRPC::Channel* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
      mutable_channels();
  const ::MurmurRPC::Channel& channels(int index) const;
  ::MurmurRPC::Channel* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
      channels() const;

  // repeated .MurmurRPC.Channel trees = 5;
  int trees_size() const;
  void clear_trees();
  static const int kTreesFieldNumber = 5;
  ::MurmurRPC::Channel* mutable_trees(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
      mutable_trees();
  const ::MurmurRPC::Channel& trees(int index) const;
  ::MurmurRPC::Channel* add_trees();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
      trees() const;

  // optional string text = 6;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 6;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User actor = 2;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 2;
  private:
  const ::MurmurRPC::User& _internal_actor() const;
  public:
  const ::MurmurRPC::User& actor() const;
  ::MurmurRPC::User* release_actor();
  ::MurmurRPC::User* mutable_actor();
  void set_allocated_actor(::MurmurRPC::User* actor);

  // @@protoc_insertion_point(class_scope:MurmurRPC.TextMessage)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_actor();
  void clear_has_actor();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User > users_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel > channels_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel > trees_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* actor_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Log.Query) */ {
 public:
  Log_Query();
  virtual ~Log_Query();

  Log_Query(const Log_Query& from);

  inline Log_Query& operator=(const Log_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Log_Query(Log_Query&& from) noexcept
    : Log_Query() {
    *this = ::std::move(from);
  }

  inline Log_Query& operator=(Log_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log_Query* internal_default_instance() {
    return reinterpret_cast<const Log_Query*>(
               &_Log_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Log_Query* other);
  friend void swap(Log_Query& a, Log_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Log_Query* New() const final {
    return CreateMaybeMessage<Log_Query>(NULL);
  }

  Log_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Log_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Log_Query& from);
  void MergeFrom(const Log_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional uint32 min = 2;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 2;
  ::google::protobuf::uint32 min() const;
  void set_min(::google::protobuf::uint32 value);

  // optional uint32 max = 3;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 3;
  ::google::protobuf::uint32 max() const;
  void set_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Log.Query)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  ::google::protobuf::uint32 min_;
  ::google::protobuf::uint32 max_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Log.List) */ {
 public:
  Log_List();
  virtual ~Log_List();

  Log_List(const Log_List& from);

  inline Log_List& operator=(const Log_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Log_List(Log_List&& from) noexcept
    : Log_List() {
    *this = ::std::move(from);
  }

  inline Log_List& operator=(Log_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log_List* internal_default_instance() {
    return reinterpret_cast<const Log_List*>(
               &_Log_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Log_List* other);
  friend void swap(Log_List& a, Log_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Log_List* New() const final {
    return CreateMaybeMessage<Log_List>(NULL);
  }

  Log_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Log_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Log_List& from);
  void MergeFrom(const Log_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Log entries = 5;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 5;
  ::MurmurRPC::Log* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Log >*
      mutable_entries();
  const ::MurmurRPC::Log& entries(int index) const;
  ::MurmurRPC::Log* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Log >&
      entries() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional uint32 total = 2;
  bool has_total() const;
  void clear_total();
  static const int kTotalFieldNumber = 2;
  ::google::protobuf::uint32 total() const;
  void set_total(::google::protobuf::uint32 value);

  // optional uint32 min = 3;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 3;
  ::google::protobuf::uint32 min() const;
  void set_min(::google::protobuf::uint32 value);

  // optional uint32 max = 4;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 4;
  ::google::protobuf::uint32 max() const;
  void set_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Log.List)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_total();
  void clear_has_total();
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Log > entries_;
  ::MurmurRPC::Server* server_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 min_;
  ::google::protobuf::uint32 max_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(Log&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Log* other);
  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(NULL);
  }

  Log* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Log_Query Query;
  typedef Log_List List;

  // accessors -------------------------------------------------------

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Log)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::MurmurRPC::Server* server_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config_FieldsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Config_FieldsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Config_FieldsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Config_FieldsEntry_DoNotUse();
  Config_FieldsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Config_FieldsEntry_DoNotUse& other);
  static const Config_FieldsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Config_FieldsEntry_DoNotUse*>(&_Config_FieldsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Config_Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Config.Field) */ {
 public:
  Config_Field();
  virtual ~Config_Field();

  Config_Field(const Config_Field& from);

  inline Config_Field& operator=(const Config_Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config_Field(Config_Field&& from) noexcept
    : Config_Field() {
    *this = ::std::move(from);
  }

  inline Config_Field& operator=(Config_Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config_Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config_Field* internal_default_instance() {
    return reinterpret_cast<const Config_Field*>(
               &_Config_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Config_Field* other);
  friend void swap(Config_Field& a, Config_Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config_Field* New() const final {
    return CreateMaybeMessage<Config_Field>(NULL);
  }

  Config_Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config_Field>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config_Field& from);
  void MergeFrom(const Config_Field& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Config.Field)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_Field Field;

  // accessors -------------------------------------------------------

  // map<string, string> fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      fields() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_fields();

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Config)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      Config_FieldsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > fields_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Channel_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Channel.Query) */ {
 public:
  Channel_Query();
  virtual ~Channel_Query();

  Channel_Query(const Channel_Query& from);

  inline Channel_Query& operator=(const Channel_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel_Query(Channel_Query&& from) noexcept
    : Channel_Query() {
    *this = ::std::move(from);
  }

  inline Channel_Query& operator=(Channel_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel_Query* internal_default_instance() {
    return reinterpret_cast<const Channel_Query*>(
               &_Channel_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Channel_Query* other);
  friend void swap(Channel_Query& a, Channel_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel_Query* New() const final {
    return CreateMaybeMessage<Channel_Query>(NULL);
  }

  Channel_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel_Query& from);
  void MergeFrom(const Channel_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Channel.Query)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Channel_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Channel.List) */ {
 public:
  Channel_List();
  virtual ~Channel_List();

  Channel_List(const Channel_List& from);

  inline Channel_List& operator=(const Channel_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel_List(Channel_List&& from) noexcept
    : Channel_List() {
    *this = ::std::move(from);
  }

  inline Channel_List& operator=(Channel_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel_List* internal_default_instance() {
    return reinterpret_cast<const Channel_List*>(
               &_Channel_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Channel_List* other);
  friend void swap(Channel_List& a, Channel_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel_List* New() const final {
    return CreateMaybeMessage<Channel_List>(NULL);
  }

  Channel_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel_List& from);
  void MergeFrom(const Channel_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Channel channels = 2;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::MurmurRPC::Channel* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
      mutable_channels();
  const ::MurmurRPC::Channel& channels(int index) const;
  ::MurmurRPC::Channel* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
      channels() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Channel.List)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel > channels_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(NULL);
  }

  Channel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Channel_Query Query;
  typedef Channel_List List;

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Channel links = 5;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 5;
  ::MurmurRPC::Channel* mutable_links(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
      mutable_links();
  const ::MurmurRPC::Channel& links(int index) const;
  ::MurmurRPC::Channel* add_links();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
      links() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 6;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 6;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Channel parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  private:
  const ::MurmurRPC::Channel& _internal_parent() const;
  public:
  const ::MurmurRPC::Channel& parent() const;
  ::MurmurRPC::Channel* release_parent();
  ::MurmurRPC::Channel* mutable_parent();
  void set_allocated_parent(::MurmurRPC::Channel* parent);

  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional bool temporary = 7;
  bool has_temporary() const;
  void clear_temporary();
  static const int kTemporaryFieldNumber = 7;
  bool temporary() const;
  void set_temporary(bool value);

  // optional int32 position = 8;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 8;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Channel)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_parent();
  void clear_has_parent();
  void set_has_description();
  void clear_has_description();
  void set_has_temporary();
  void clear_has_temporary();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel > links_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::Channel* parent_;
  ::google::protobuf::uint32 id_;
  bool temporary_;
  ::google::protobuf::int32 position_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.User.Query) */ {
 public:
  User_Query();
  virtual ~User_Query();

  User_Query(const User_Query& from);

  inline User_Query& operator=(const User_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User_Query(User_Query&& from) noexcept
    : User_Query() {
    *this = ::std::move(from);
  }

  inline User_Query& operator=(User_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User_Query* internal_default_instance() {
    return reinterpret_cast<const User_Query*>(
               &_User_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(User_Query* other);
  friend void swap(User_Query& a, User_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User_Query* New() const final {
    return CreateMaybeMessage<User_Query>(NULL);
  }

  User_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User_Query& from);
  void MergeFrom(const User_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.User.Query)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.User.List) */ {
 public:
  User_List();
  virtual ~User_List();

  User_List(const User_List& from);

  inline User_List& operator=(const User_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User_List(User_List&& from) noexcept
    : User_List() {
    *this = ::std::move(from);
  }

  inline User_List& operator=(User_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User_List* internal_default_instance() {
    return reinterpret_cast<const User_List*>(
               &_User_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(User_List* other);
  friend void swap(User_List& a, User_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User_List* New() const final {
    return CreateMaybeMessage<User_List>(NULL);
  }

  User_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User_List& from);
  void MergeFrom(const User_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.User users = 2;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  ::MurmurRPC::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
      mutable_users();
  const ::MurmurRPC::User& users(int index) const;
  ::MurmurRPC::User* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
      users() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.User.List)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User > users_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User_Kick : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.User.Kick) */ {
 public:
  User_Kick();
  virtual ~User_Kick();

  User_Kick(const User_Kick& from);

  inline User_Kick& operator=(const User_Kick& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User_Kick(User_Kick&& from) noexcept
    : User_Kick() {
    *this = ::std::move(from);
  }

  inline User_Kick& operator=(User_Kick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User_Kick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User_Kick* internal_default_instance() {
    return reinterpret_cast<const User_Kick*>(
               &_User_Kick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(User_Kick* other);
  friend void swap(User_Kick& a, User_Kick& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User_Kick* New() const final {
    return CreateMaybeMessage<User_Kick>(NULL);
  }

  User_Kick* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User_Kick>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User_Kick& from);
  void MergeFrom(const User_Kick& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User_Kick* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 4;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 4;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // optional .MurmurRPC.User actor = 3;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 3;
  private:
  const ::MurmurRPC::User& _internal_actor() const;
  public:
  const ::MurmurRPC::User& actor() const;
  ::MurmurRPC::User* release_actor();
  ::MurmurRPC::User* mutable_actor();
  void set_allocated_actor(::MurmurRPC::User* actor);

  // @@protoc_insertion_point(class_scope:MurmurRPC.User.Kick)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_user();
  void clear_has_user();
  void set_has_actor();
  void clear_has_actor();
  void set_has_reason();
  void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* user_;
  ::MurmurRPC::User* actor_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(NULL);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef User_Query Query;
  typedef User_List List;
  typedef User_Kick Kick;

  // accessors -------------------------------------------------------

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes plugin_context = 17;
  bool has_plugin_context() const;
  void clear_plugin_context();
  static const int kPluginContextFieldNumber = 17;
  const ::std::string& plugin_context() const;
  void set_plugin_context(const ::std::string& value);
  #if LANG_CXX11
  void set_plugin_context(::std::string&& value);
  #endif
  void set_plugin_context(const char* value);
  void set_plugin_context(const void* value, size_t size);
  ::std::string* mutable_plugin_context();
  ::std::string* release_plugin_context();
  void set_allocated_plugin_context(::std::string* plugin_context);

  // optional string plugin_identity = 18;
  bool has_plugin_identity() const;
  void clear_plugin_identity();
  static const int kPluginIdentityFieldNumber = 18;
  const ::std::string& plugin_identity() const;
  void set_plugin_identity(const ::std::string& value);
  #if LANG_CXX11
  void set_plugin_identity(::std::string&& value);
  #endif
  void set_plugin_identity(const char* value);
  void set_plugin_identity(const char* value, size_t size);
  ::std::string* mutable_plugin_identity();
  ::std::string* release_plugin_identity();
  void set_allocated_plugin_identity(::std::string* plugin_identity);

  // optional string comment = 19;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 19;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional bytes texture = 20;
  bool has_texture() const;
  void clear_texture();
  static const int kTextureFieldNumber = 20;
  const ::std::string& texture() const;
  void set_texture(const ::std::string& value);
  #if LANG_CXX11
  void set_texture(::std::string&& value);
  #endif
  void set_texture(const char* value);
  void set_texture(const void* value, size_t size);
  ::std::string* mutable_texture();
  ::std::string* release_texture();
  void set_allocated_texture(::std::string* texture);

  // optional bytes address = 21;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 21;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Channel channel = 12;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 12;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // optional .MurmurRPC.Version version = 16;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 16;
  private:
  const ::MurmurRPC::Version& _internal_version() const;
  public:
  const ::MurmurRPC::Version& version() const;
  ::MurmurRPC::Version* release_version();
  ::MurmurRPC::Version* mutable_version();
  void set_allocated_version(::MurmurRPC::Version* version);

  // optional uint32 session = 2;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional bool mute = 5;
  bool has_mute() const;
  void clear_mute();
  static const int kMuteFieldNumber = 5;
  bool mute() const;
  void set_mute(bool value);

  // optional bool deaf = 6;
  bool has_deaf() const;
  void clear_deaf();
  static const int kDeafFieldNumber = 6;
  bool deaf() const;
  void set_deaf(bool value);

  // optional bool suppress = 7;
  bool has_suppress() const;
  void clear_suppress();
  static const int kSuppressFieldNumber = 7;
  bool suppress() const;
  void set_suppress(bool value);

  // optional bool priority_speaker = 8;
  bool has_priority_speaker() const;
  void clear_priority_speaker();
  static const int kPrioritySpeakerFieldNumber = 8;
  bool priority_speaker() const;
  void set_priority_speaker(bool value);

  // optional uint32 online_secs = 13;
  bool has_online_secs() const;
  void clear_online_secs();
  static const int kOnlineSecsFieldNumber = 13;
  ::google::protobuf::uint32 online_secs() const;
  void set_online_secs(::google::protobuf::uint32 value);

  // optional bool self_mute = 9;
  bool has_self_mute() const;
  void clear_self_mute();
  static const int kSelfMuteFieldNumber = 9;
  bool self_mute() const;
  void set_self_mute(bool value);

  // optional bool self_deaf = 10;
  bool has_self_deaf() const;
  void clear_self_deaf();
  static const int kSelfDeafFieldNumber = 10;
  bool self_deaf() const;
  void set_self_deaf(bool value);

  // optional bool recording = 11;
  bool has_recording() const;
  void clear_recording();
  static const int kRecordingFieldNumber = 11;
  bool recording() const;
  void set_recording(bool value);

  // optional bool tcp_only = 22;
  bool has_tcp_only() const;
  void clear_tcp_only();
  static const int kTcpOnlyFieldNumber = 22;
  bool tcp_only() const;
  void set_tcp_only(bool value);

  // optional uint32 idle_secs = 14;
  bool has_idle_secs() const;
  void clear_idle_secs();
  static const int kIdleSecsFieldNumber = 14;
  ::google::protobuf::uint32 idle_secs() const;
  void set_idle_secs(::google::protobuf::uint32 value);

  // optional uint32 bytes_per_sec = 15;
  bool has_bytes_per_sec() const;
  void clear_bytes_per_sec();
  static const int kBytesPerSecFieldNumber = 15;
  ::google::protobuf::uint32 bytes_per_sec() const;
  void set_bytes_per_sec(::google::protobuf::uint32 value);

  // optional float udp_ping_msecs = 23;
  bool has_udp_ping_msecs() const;
  void clear_udp_ping_msecs();
  static const int kUdpPingMsecsFieldNumber = 23;
  float udp_ping_msecs() const;
  void set_udp_ping_msecs(float value);

  // optional float tcp_ping_msecs = 24;
  bool has_tcp_ping_msecs() const;
  void clear_tcp_ping_msecs();
  static const int kTcpPingMsecsFieldNumber = 24;
  float tcp_ping_msecs() const;
  void set_tcp_ping_msecs(float value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.User)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_session();
  void clear_has_session();
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_mute();
  void clear_has_mute();
  void set_has_deaf();
  void clear_has_deaf();
  void set_has_suppress();
  void clear_has_suppress();
  void set_has_priority_speaker();
  void clear_has_priority_speaker();
  void set_has_self_mute();
  void clear_has_self_mute();
  void set_has_self_deaf();
  void clear_has_self_deaf();
  void set_has_recording();
  void clear_has_recording();
  void set_has_channel();
  void clear_has_channel();
  void set_has_online_secs();
  void clear_has_online_secs();
  void set_has_idle_secs();
  void clear_has_idle_secs();
  void set_has_bytes_per_sec();
  void clear_has_bytes_per_sec();
  void set_has_version();
  void clear_has_version();
  void set_has_plugin_context();
  void clear_has_plugin_context();
  void set_has_plugin_identity();
  void clear_has_plugin_identity();
  void set_has_comment();
  void clear_has_comment();
  void set_has_texture();
  void clear_has_texture();
  void set_has_address();
  void clear_has_address();
  void set_has_tcp_only();
  void clear_has_tcp_only();
  void set_has_udp_ping_msecs();
  void clear_has_udp_ping_msecs();
  void set_has_tcp_ping_msecs();
  void clear_has_tcp_ping_msecs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr plugin_context_;
  ::google::protobuf::internal::ArenaStringPtr plugin_identity_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr texture_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::Channel* channel_;
  ::MurmurRPC::Version* version_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 id_;
  bool mute_;
  bool deaf_;
  bool suppress_;
  bool priority_speaker_;
  ::google::protobuf::uint32 online_secs_;
  bool self_mute_;
  bool self_deaf_;
  bool recording_;
  bool tcp_only_;
  ::google::protobuf::uint32 idle_secs_;
  ::google::protobuf::uint32 bytes_per_sec_;
  float udp_ping_msecs_;
  float tcp_ping_msecs_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tree_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Tree.Query) */ {
 public:
  Tree_Query();
  virtual ~Tree_Query();

  Tree_Query(const Tree_Query& from);

  inline Tree_Query& operator=(const Tree_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tree_Query(Tree_Query&& from) noexcept
    : Tree_Query() {
    *this = ::std::move(from);
  }

  inline Tree_Query& operator=(Tree_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tree_Query* internal_default_instance() {
    return reinterpret_cast<const Tree_Query*>(
               &_Tree_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Tree_Query* other);
  friend void swap(Tree_Query& a, Tree_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tree_Query* New() const final {
    return CreateMaybeMessage<Tree_Query>(NULL);
  }

  Tree_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tree_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tree_Query& from);
  void MergeFrom(const Tree_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tree_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Tree.Query)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Tree) */ {
 public:
  Tree();
  virtual ~Tree();

  Tree(const Tree& from);

  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tree(Tree&& from) noexcept
    : Tree() {
    *this = ::std::move(from);
  }

  inline Tree& operator=(Tree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tree* internal_default_instance() {
    return reinterpret_cast<const Tree*>(
               &_Tree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(Tree* other);
  friend void swap(Tree& a, Tree& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tree* New() const final {
    return CreateMaybeMessage<Tree>(NULL);
  }

  Tree* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tree>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tree* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Tree_Query Query;

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Tree children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  ::MurmurRPC::Tree* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Tree >*
      mutable_children();
  const ::MurmurRPC::Tree& children(int index) const;
  ::MurmurRPC::Tree* add_children();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Tree >&
      children() const;

  // repeated .MurmurRPC.User users = 4;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 4;
  ::MurmurRPC::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
      mutable_users();
  const ::MurmurRPC::User& users(int index) const;
  ::MurmurRPC::User* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
      users() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Tree)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_channel();
  void clear_has_channel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Tree > children_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User > users_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::Channel* channel_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ban_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Ban.Query) */ {
 public:
  Ban_Query();
  virtual ~Ban_Query();

  Ban_Query(const Ban_Query& from);

  inline Ban_Query& operator=(const Ban_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ban_Query(Ban_Query&& from) noexcept
    : Ban_Query() {
    *this = ::std::move(from);
  }

  inline Ban_Query& operator=(Ban_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ban_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ban_Query* internal_default_instance() {
    return reinterpret_cast<const Ban_Query*>(
               &_Ban_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Ban_Query* other);
  friend void swap(Ban_Query& a, Ban_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ban_Query* New() const final {
    return CreateMaybeMessage<Ban_Query>(NULL);
  }

  Ban_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ban_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ban_Query& from);
  void MergeFrom(const Ban_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ban_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Ban.Query)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ban_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Ban.List) */ {
 public:
  Ban_List();
  virtual ~Ban_List();

  Ban_List(const Ban_List& from);

  inline Ban_List& operator=(const Ban_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ban_List(Ban_List&& from) noexcept
    : Ban_List() {
    *this = ::std::move(from);
  }

  inline Ban_List& operator=(Ban_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ban_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ban_List* internal_default_instance() {
    return reinterpret_cast<const Ban_List*>(
               &_Ban_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Ban_List* other);
  friend void swap(Ban_List& a, Ban_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ban_List* New() const final {
    return CreateMaybeMessage<Ban_List>(NULL);
  }

  Ban_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ban_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ban_List& from);
  void MergeFrom(const Ban_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ban_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.Ban bans = 2;
  int bans_size() const;
  void clear_bans();
  static const int kBansFieldNumber = 2;
  ::MurmurRPC::Ban* mutable_bans(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Ban >*
      mutable_bans();
  const ::MurmurRPC::Ban& bans(int index) const;
  ::MurmurRPC::Ban* add_bans();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Ban >&
      bans() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Ban.List)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Ban > bans_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ban : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Ban) */ {
 public:
  Ban();
  virtual ~Ban();

  Ban(const Ban& from);

  inline Ban& operator=(const Ban& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ban(Ban&& from) noexcept
    : Ban() {
    *this = ::std::move(from);
  }

  inline Ban& operator=(Ban&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ban& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ban* internal_default_instance() {
    return reinterpret_cast<const Ban*>(
               &_Ban_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Ban* other);
  friend void swap(Ban& a, Ban& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ban* New() const final {
    return CreateMaybeMessage<Ban>(NULL);
  }

  Ban* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ban>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ban& from);
  void MergeFrom(const Ban& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ban* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Ban_Query Query;
  typedef Ban_List List;

  // accessors -------------------------------------------------------

  // optional bytes address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string hash = 5;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 5;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string reason = 6;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 6;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional int64 start = 7;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 7;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // optional int64 duration_secs = 8;
  bool has_duration_secs() const;
  void clear_duration_secs();
  static const int kDurationSecsFieldNumber = 8;
  ::google::protobuf::int64 duration_secs() const;
  void set_duration_secs(::google::protobuf::int64 value);

  // optional uint32 bits = 3;
  bool has_bits() const;
  void clear_bits();
  static const int kBitsFieldNumber = 3;
  ::google::protobuf::uint32 bits() const;
  void set_bits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Ban)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_address();
  void clear_has_address();
  void set_has_bits();
  void clear_has_bits();
  void set_has_name();
  void clear_has_name();
  void set_has_hash();
  void clear_has_hash();
  void set_has_reason();
  void clear_has_reason();
  void set_has_start();
  void clear_has_start();
  void set_has_duration_secs();
  void clear_has_duration_secs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::MurmurRPC::Server* server_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 duration_secs_;
  ::google::protobuf::uint32 bits_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ACL_Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ACL.Group) */ {
 public:
  ACL_Group();
  virtual ~ACL_Group();

  ACL_Group(const ACL_Group& from);

  inline ACL_Group& operator=(const ACL_Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_Group(ACL_Group&& from) noexcept
    : ACL_Group() {
    *this = ::std::move(from);
  }

  inline ACL_Group& operator=(ACL_Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_Group* internal_default_instance() {
    return reinterpret_cast<const ACL_Group*>(
               &_ACL_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ACL_Group* other);
  friend void swap(ACL_Group& a, ACL_Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_Group* New() const final {
    return CreateMaybeMessage<ACL_Group>(NULL);
  }

  ACL_Group* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_Group>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_Group& from);
  void MergeFrom(const ACL_Group& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.DatabaseUser users_add = 5;
  int users_add_size() const;
  void clear_users_add();
  static const int kUsersAddFieldNumber = 5;
  ::MurmurRPC::DatabaseUser* mutable_users_add(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
      mutable_users_add();
  const ::MurmurRPC::DatabaseUser& users_add(int index) const;
  ::MurmurRPC::DatabaseUser* add_users_add();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
      users_add() const;

  // repeated .MurmurRPC.DatabaseUser users_remove = 6;
  int users_remove_size() const;
  void clear_users_remove();
  static const int kUsersRemoveFieldNumber = 6;
  ::MurmurRPC::DatabaseUser* mutable_users_remove(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
      mutable_users_remove();
  const ::MurmurRPC::DatabaseUser& users_remove(int index) const;
  ::MurmurRPC::DatabaseUser* add_users_remove();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
      users_remove() const;

  // repeated .MurmurRPC.DatabaseUser users = 7;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 7;
  ::MurmurRPC::DatabaseUser* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
      mutable_users();
  const ::MurmurRPC::DatabaseUser& users(int index) const;
  ::MurmurRPC::DatabaseUser* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
      users() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool inherited = 2;
  bool has_inherited() const;
  void clear_inherited();
  static const int kInheritedFieldNumber = 2;
  bool inherited() const;
  void set_inherited(bool value);

  // optional bool inherit = 3;
  bool has_inherit() const;
  void clear_inherit();
  static const int kInheritFieldNumber = 3;
  bool inherit() const;
  void set_inherit(bool value);

  // optional bool inheritable = 4;
  bool has_inheritable() const;
  void clear_inheritable();
  static const int kInheritableFieldNumber = 4;
  bool inheritable() const;
  void set_inheritable(bool value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ACL.Group)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_inherited();
  void clear_has_inherited();
  void set_has_inherit();
  void clear_has_inherit();
  void set_has_inheritable();
  void clear_has_inheritable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser > users_add_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser > users_remove_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser > users_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool inherited_;
  bool inherit_;
  bool inheritable_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ACL_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ACL.Query) */ {
 public:
  ACL_Query();
  virtual ~ACL_Query();

  ACL_Query(const ACL_Query& from);

  inline ACL_Query& operator=(const ACL_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_Query(ACL_Query&& from) noexcept
    : ACL_Query() {
    *this = ::std::move(from);
  }

  inline ACL_Query& operator=(ACL_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_Query* internal_default_instance() {
    return reinterpret_cast<const ACL_Query*>(
               &_ACL_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ACL_Query* other);
  friend void swap(ACL_Query& a, ACL_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_Query* New() const final {
    return CreateMaybeMessage<ACL_Query>(NULL);
  }

  ACL_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_Query& from);
  void MergeFrom(const ACL_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // optional .MurmurRPC.Channel channel = 3;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ACL.Query)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_user();
  void clear_has_user();
  void set_has_channel();
  void clear_has_channel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* user_;
  ::MurmurRPC::Channel* channel_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ACL_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ACL.List) */ {
 public:
  ACL_List();
  virtual ~ACL_List();

  ACL_List(const ACL_List& from);

  inline ACL_List& operator=(const ACL_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_List(ACL_List&& from) noexcept
    : ACL_List() {
    *this = ::std::move(from);
  }

  inline ACL_List& operator=(ACL_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_List* internal_default_instance() {
    return reinterpret_cast<const ACL_List*>(
               &_ACL_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ACL_List* other);
  friend void swap(ACL_List& a, ACL_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_List* New() const final {
    return CreateMaybeMessage<ACL_List>(NULL);
  }

  ACL_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_List& from);
  void MergeFrom(const ACL_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.ACL acls = 3;
  int acls_size() const;
  void clear_acls();
  static const int kAclsFieldNumber = 3;
  ::MurmurRPC::ACL* mutable_acls(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL >*
      mutable_acls();
  const ::MurmurRPC::ACL& acls(int index) const;
  ::MurmurRPC::ACL* add_acls();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL >&
      acls() const;

  // repeated .MurmurRPC.ACL.Group groups = 4;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 4;
  ::MurmurRPC::ACL_Group* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >*
      mutable_groups();
  const ::MurmurRPC::ACL_Group& groups(int index) const;
  ::MurmurRPC::ACL_Group* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >&
      groups() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // optional bool inherit = 5;
  bool has_inherit() const;
  void clear_inherit();
  static const int kInheritFieldNumber = 5;
  bool inherit() const;
  void set_inherit(bool value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ACL.List)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_channel();
  void clear_has_channel();
  void set_has_inherit();
  void clear_has_inherit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL > acls_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group > groups_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::Channel* channel_;
  bool inherit_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ACL_TemporaryGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ACL.TemporaryGroup) */ {
 public:
  ACL_TemporaryGroup();
  virtual ~ACL_TemporaryGroup();

  ACL_TemporaryGroup(const ACL_TemporaryGroup& from);

  inline ACL_TemporaryGroup& operator=(const ACL_TemporaryGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_TemporaryGroup(ACL_TemporaryGroup&& from) noexcept
    : ACL_TemporaryGroup() {
    *this = ::std::move(from);
  }

  inline ACL_TemporaryGroup& operator=(ACL_TemporaryGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_TemporaryGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_TemporaryGroup* internal_default_instance() {
    return reinterpret_cast<const ACL_TemporaryGroup*>(
               &_ACL_TemporaryGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ACL_TemporaryGroup* other);
  friend void swap(ACL_TemporaryGroup& a, ACL_TemporaryGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_TemporaryGroup* New() const final {
    return CreateMaybeMessage<ACL_TemporaryGroup>(NULL);
  }

  ACL_TemporaryGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_TemporaryGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_TemporaryGroup& from);
  void MergeFrom(const ACL_TemporaryGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_TemporaryGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  private:
  const ::MurmurRPC::Channel& _internal_channel() const;
  public:
  const ::MurmurRPC::Channel& channel() const;
  ::MurmurRPC::Channel* release_channel();
  ::MurmurRPC::Channel* mutable_channel();
  void set_allocated_channel(::MurmurRPC::Channel* channel);

  // optional .MurmurRPC.User user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ACL.TemporaryGroup)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_channel();
  void clear_has_channel();
  void set_has_user();
  void clear_has_user();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::Channel* channel_;
  ::MurmurRPC::User* user_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.ACL) */ {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL(ACL&& from) noexcept
    : ACL() {
    *this = ::std::move(from);
  }

  inline ACL& operator=(ACL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL* internal_default_instance() {
    return reinterpret_cast<const ACL*>(
               &_ACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(ACL* other);
  friend void swap(ACL& a, ACL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL* New() const final {
    return CreateMaybeMessage<ACL>(NULL);
  }

  ACL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ACL_Group Group;
  typedef ACL_Query Query;
  typedef ACL_List List;
  typedef ACL_TemporaryGroup TemporaryGroup;

  typedef ACL_Permission Permission;
  static const Permission None =
    ACL_Permission_None;
  static const Permission Write =
    ACL_Permission_Write;
  static const Permission Traverse =
    ACL_Permission_Traverse;
  static const Permission Enter =
    ACL_Permission_Enter;
  static const Permission Speak =
    ACL_Permission_Speak;
  static const Permission Whisper =
    ACL_Permission_Whisper;
  static const Permission MuteDeafen =
    ACL_Permission_MuteDeafen;
  static const Permission Move =
    ACL_Permission_Move;
  static const Permission MakeChannel =
    ACL_Permission_MakeChannel;
  static const Permission MakeTemporaryChannel =
    ACL_Permission_MakeTemporaryChannel;
  static const Permission LinkChannel =
    ACL_Permission_LinkChannel;
  static const Permission TextMessage =
    ACL_Permission_TextMessage;
  static const Permission Kick =
    ACL_Permission_Kick;
  static const Permission Ban =
    ACL_Permission_Ban;
  static const Permission Register =
    ACL_Permission_Register;
  static const Permission RegisterSelf =
    ACL_Permission_RegisterSelf;
  static inline bool Permission_IsValid(int value) {
    return ACL_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    ACL_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    ACL_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    ACL_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return ACL_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return ACL_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return ACL_Permission_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 6;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 6;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // optional .MurmurRPC.ACL.Group group = 7;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 7;
  private:
  const ::MurmurRPC::ACL_Group& _internal_group() const;
  public:
  const ::MurmurRPC::ACL_Group& group() const;
  ::MurmurRPC::ACL_Group* release_group();
  ::MurmurRPC::ACL_Group* mutable_group();
  void set_allocated_group(::MurmurRPC::ACL_Group* group);

  // optional bool apply_here = 3;
  bool has_apply_here() const;
  void clear_apply_here();
  static const int kApplyHereFieldNumber = 3;
  bool apply_here() const;
  void set_apply_here(bool value);

  // optional bool apply_subs = 4;
  bool has_apply_subs() const;
  void clear_apply_subs();
  static const int kApplySubsFieldNumber = 4;
  bool apply_subs() const;
  void set_apply_subs(bool value);

  // optional bool inherited = 5;
  bool has_inherited() const;
  void clear_inherited();
  static const int kInheritedFieldNumber = 5;
  bool inherited() const;
  void set_inherited(bool value);

  // optional uint32 allow = 8;
  bool has_allow() const;
  void clear_allow();
  static const int kAllowFieldNumber = 8;
  ::google::protobuf::uint32 allow() const;
  void set_allow(::google::protobuf::uint32 value);

  // optional uint32 deny = 9;
  bool has_deny() const;
  void clear_deny();
  static const int kDenyFieldNumber = 9;
  ::google::protobuf::uint32 deny() const;
  void set_deny(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.ACL)
 private:
  void set_has_apply_here();
  void clear_has_apply_here();
  void set_has_apply_subs();
  void clear_has_apply_subs();
  void set_has_inherited();
  void clear_has_inherited();
  void set_has_user();
  void clear_has_user();
  void set_has_group();
  void clear_has_group();
  void set_has_allow();
  void clear_has_allow();
  void set_has_deny();
  void clear_has_deny();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  ::MurmurRPC::ACL_Group* group_;
  bool apply_here_;
  bool apply_subs_;
  bool inherited_;
  ::google::protobuf::uint32 allow_;
  ::google::protobuf::uint32 deny_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Authenticate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Authenticate) */ {
 public:
  Authenticator_Request_Authenticate();
  virtual ~Authenticator_Request_Authenticate();

  Authenticator_Request_Authenticate(const Authenticator_Request_Authenticate& from);

  inline Authenticator_Request_Authenticate& operator=(const Authenticator_Request_Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Authenticate(Authenticator_Request_Authenticate&& from) noexcept
    : Authenticator_Request_Authenticate() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Authenticate& operator=(Authenticator_Request_Authenticate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Authenticate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Authenticate* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Authenticate*>(
               &_Authenticator_Request_Authenticate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Authenticator_Request_Authenticate* other);
  friend void swap(Authenticator_Request_Authenticate& a, Authenticator_Request_Authenticate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Authenticate* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Authenticate>(NULL);
  }

  Authenticator_Request_Authenticate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Authenticate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Authenticate& from);
  void MergeFrom(const Authenticator_Request_Authenticate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Authenticate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes certificates = 3;
  int certificates_size() const;
  void clear_certificates();
  static const int kCertificatesFieldNumber = 3;
  const ::std::string& certificates(int index) const;
  ::std::string* mutable_certificates(int index);
  void set_certificates(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_certificates(int index, ::std::string&& value);
  #endif
  void set_certificates(int index, const char* value);
  void set_certificates(int index, const void* value, size_t size);
  ::std::string* add_certificates();
  void add_certificates(const ::std::string& value);
  #if LANG_CXX11
  void add_certificates(::std::string&& value);
  #endif
  void add_certificates(const char* value);
  void add_certificates(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& certificates() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificates();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string certificate_hash = 4;
  bool has_certificate_hash() const;
  void clear_certificate_hash();
  static const int kCertificateHashFieldNumber = 4;
  const ::std::string& certificate_hash() const;
  void set_certificate_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_certificate_hash(::std::string&& value);
  #endif
  void set_certificate_hash(const char* value);
  void set_certificate_hash(const char* value, size_t size);
  ::std::string* mutable_certificate_hash();
  ::std::string* release_certificate_hash();
  void set_allocated_certificate_hash(::std::string* certificate_hash);

  // optional bool strong_certificate = 5;
  bool has_strong_certificate() const;
  void clear_strong_certificate();
  static const int kStrongCertificateFieldNumber = 5;
  bool strong_certificate() const;
  void set_strong_certificate(bool value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Authenticate)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_password();
  void clear_has_password();
  void set_has_certificate_hash();
  void clear_has_certificate_hash();
  void set_has_strong_certificate();
  void clear_has_strong_certificate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificates_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr certificate_hash_;
  bool strong_certificate_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Find : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Find) */ {
 public:
  Authenticator_Request_Find();
  virtual ~Authenticator_Request_Find();

  Authenticator_Request_Find(const Authenticator_Request_Find& from);

  inline Authenticator_Request_Find& operator=(const Authenticator_Request_Find& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Find(Authenticator_Request_Find&& from) noexcept
    : Authenticator_Request_Find() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Find& operator=(Authenticator_Request_Find&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Find& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Find* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Find*>(
               &_Authenticator_Request_Find_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Authenticator_Request_Find* other);
  friend void swap(Authenticator_Request_Find& a, Authenticator_Request_Find& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Find* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Find>(NULL);
  }

  Authenticator_Request_Find* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Find>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Find& from);
  void MergeFrom(const Authenticator_Request_Find& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Find* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Find)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Query) */ {
 public:
  Authenticator_Request_Query();
  virtual ~Authenticator_Request_Query();

  Authenticator_Request_Query(const Authenticator_Request_Query& from);

  inline Authenticator_Request_Query& operator=(const Authenticator_Request_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Query(Authenticator_Request_Query&& from) noexcept
    : Authenticator_Request_Query() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Query& operator=(Authenticator_Request_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Query* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Query*>(
               &_Authenticator_Request_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(Authenticator_Request_Query* other);
  friend void swap(Authenticator_Request_Query& a, Authenticator_Request_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Query* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Query>(NULL);
  }

  Authenticator_Request_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Query& from);
  void MergeFrom(const Authenticator_Request_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filter = 1;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Query)
 private:
  void set_has_filter();
  void clear_has_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Register) */ {
 public:
  Authenticator_Request_Register();
  virtual ~Authenticator_Request_Register();

  Authenticator_Request_Register(const Authenticator_Request_Register& from);

  inline Authenticator_Request_Register& operator=(const Authenticator_Request_Register& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Register(Authenticator_Request_Register&& from) noexcept
    : Authenticator_Request_Register() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Register& operator=(Authenticator_Request_Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Register* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Register*>(
               &_Authenticator_Request_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(Authenticator_Request_Register* other);
  friend void swap(Authenticator_Request_Register& a, Authenticator_Request_Register& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Register* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Register>(NULL);
  }

  Authenticator_Request_Register* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Register>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Register& from);
  void MergeFrom(const Authenticator_Request_Register& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Register)
 private:
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Deregister : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Deregister) */ {
 public:
  Authenticator_Request_Deregister();
  virtual ~Authenticator_Request_Deregister();

  Authenticator_Request_Deregister(const Authenticator_Request_Deregister& from);

  inline Authenticator_Request_Deregister& operator=(const Authenticator_Request_Deregister& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Deregister(Authenticator_Request_Deregister&& from) noexcept
    : Authenticator_Request_Deregister() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Deregister& operator=(Authenticator_Request_Deregister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Deregister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Deregister* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Deregister*>(
               &_Authenticator_Request_Deregister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(Authenticator_Request_Deregister* other);
  friend void swap(Authenticator_Request_Deregister& a, Authenticator_Request_Deregister& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Deregister* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Deregister>(NULL);
  }

  Authenticator_Request_Deregister* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Deregister>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Deregister& from);
  void MergeFrom(const Authenticator_Request_Deregister& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Deregister* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Deregister)
 private:
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request_Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request.Update) */ {
 public:
  Authenticator_Request_Update();
  virtual ~Authenticator_Request_Update();

  Authenticator_Request_Update(const Authenticator_Request_Update& from);

  inline Authenticator_Request_Update& operator=(const Authenticator_Request_Update& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request_Update(Authenticator_Request_Update&& from) noexcept
    : Authenticator_Request_Update() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request_Update& operator=(Authenticator_Request_Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request_Update& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request_Update* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request_Update*>(
               &_Authenticator_Request_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(Authenticator_Request_Update* other);
  friend void swap(Authenticator_Request_Update& a, Authenticator_Request_Update& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request_Update* New() const final {
    return CreateMaybeMessage<Authenticator_Request_Update>(NULL);
  }

  Authenticator_Request_Update* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request_Update>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request_Update& from);
  void MergeFrom(const Authenticator_Request_Update& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request_Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request.Update)
 private:
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Request) */ {
 public:
  Authenticator_Request();
  virtual ~Authenticator_Request();

  Authenticator_Request(const Authenticator_Request& from);

  inline Authenticator_Request& operator=(const Authenticator_Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Request(Authenticator_Request&& from) noexcept
    : Authenticator_Request() {
    *this = ::std::move(from);
  }

  inline Authenticator_Request& operator=(Authenticator_Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Request* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Request*>(
               &_Authenticator_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(Authenticator_Request* other);
  friend void swap(Authenticator_Request& a, Authenticator_Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Request* New() const final {
    return CreateMaybeMessage<Authenticator_Request>(NULL);
  }

  Authenticator_Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Request& from);
  void MergeFrom(const Authenticator_Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Authenticator_Request_Authenticate Authenticate;
  typedef Authenticator_Request_Find Find;
  typedef Authenticator_Request_Query Query;
  typedef Authenticator_Request_Register Register;
  typedef Authenticator_Request_Deregister Deregister;
  typedef Authenticator_Request_Update Update;

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Authenticator.Request.Authenticate authenticate = 1;
  bool has_authenticate() const;
  void clear_authenticate();
  static const int kAuthenticateFieldNumber = 1;
  private:
  const ::MurmurRPC::Authenticator_Request_Authenticate& _internal_authenticate() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Authenticate& authenticate() const;
  ::MurmurRPC::Authenticator_Request_Authenticate* release_authenticate();
  ::MurmurRPC::Authenticator_Request_Authenticate* mutable_authenticate();
  void set_allocated_authenticate(::MurmurRPC::Authenticator_Request_Authenticate* authenticate);

  // optional .MurmurRPC.Authenticator.Request.Find find = 2;
  bool has_find() const;
  void clear_find();
  static const int kFindFieldNumber = 2;
  private:
  const ::MurmurRPC::Authenticator_Request_Find& _internal_find() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Find& find() const;
  ::MurmurRPC::Authenticator_Request_Find* release_find();
  ::MurmurRPC::Authenticator_Request_Find* mutable_find();
  void set_allocated_find(::MurmurRPC::Authenticator_Request_Find* find);

  // optional .MurmurRPC.Authenticator.Request.Query query = 3;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 3;
  private:
  const ::MurmurRPC::Authenticator_Request_Query& _internal_query() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Query& query() const;
  ::MurmurRPC::Authenticator_Request_Query* release_query();
  ::MurmurRPC::Authenticator_Request_Query* mutable_query();
  void set_allocated_query(::MurmurRPC::Authenticator_Request_Query* query);

  // optional .MurmurRPC.Authenticator.Request.Register register = 4;
  bool has_register_() const;
  void clear_register_();
  static const int kRegisterFieldNumber = 4;
  private:
  const ::MurmurRPC::Authenticator_Request_Register& _internal_register_() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Register& register_() const;
  ::MurmurRPC::Authenticator_Request_Register* release_register_();
  ::MurmurRPC::Authenticator_Request_Register* mutable_register_();
  void set_allocated_register_(::MurmurRPC::Authenticator_Request_Register* register_);

  // optional .MurmurRPC.Authenticator.Request.Deregister deregister = 5;
  bool has_deregister() const;
  void clear_deregister();
  static const int kDeregisterFieldNumber = 5;
  private:
  const ::MurmurRPC::Authenticator_Request_Deregister& _internal_deregister() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Deregister& deregister() const;
  ::MurmurRPC::Authenticator_Request_Deregister* release_deregister();
  ::MurmurRPC::Authenticator_Request_Deregister* mutable_deregister();
  void set_allocated_deregister(::MurmurRPC::Authenticator_Request_Deregister* deregister);

  // optional .MurmurRPC.Authenticator.Request.Update update = 6;
  bool has_update() const;
  void clear_update();
  static const int kUpdateFieldNumber = 6;
  private:
  const ::MurmurRPC::Authenticator_Request_Update& _internal_update() const;
  public:
  const ::MurmurRPC::Authenticator_Request_Update& update() const;
  ::MurmurRPC::Authenticator_Request_Update* release_update();
  ::MurmurRPC::Authenticator_Request_Update* mutable_update();
  void set_allocated_update(::MurmurRPC::Authenticator_Request_Update* update);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Request)
 private:
  void set_has_authenticate();
  void clear_has_authenticate();
  void set_has_find();
  void clear_has_find();
  void set_has_query();
  void clear_has_query();
  void set_has_register_();
  void clear_has_register_();
  void set_has_deregister();
  void clear_has_deregister();
  void set_has_update();
  void clear_has_update();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Authenticator_Request_Authenticate* authenticate_;
  ::MurmurRPC::Authenticator_Request_Find* find_;
  ::MurmurRPC::Authenticator_Request_Query* query_;
  ::MurmurRPC::Authenticator_Request_Register* register__;
  ::MurmurRPC::Authenticator_Request_Deregister* deregister_;
  ::MurmurRPC::Authenticator_Request_Update* update_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Initialize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Initialize) */ {
 public:
  Authenticator_Response_Initialize();
  virtual ~Authenticator_Response_Initialize();

  Authenticator_Response_Initialize(const Authenticator_Response_Initialize& from);

  inline Authenticator_Response_Initialize& operator=(const Authenticator_Response_Initialize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Initialize(Authenticator_Response_Initialize&& from) noexcept
    : Authenticator_Response_Initialize() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Initialize& operator=(Authenticator_Response_Initialize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Initialize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Initialize* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Initialize*>(
               &_Authenticator_Response_Initialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(Authenticator_Response_Initialize* other);
  friend void swap(Authenticator_Response_Initialize& a, Authenticator_Response_Initialize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Initialize* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Initialize>(NULL);
  }

  Authenticator_Response_Initialize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Initialize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Initialize& from);
  void MergeFrom(const Authenticator_Response_Initialize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Initialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Initialize)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Authenticate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Authenticate) */ {
 public:
  Authenticator_Response_Authenticate();
  virtual ~Authenticator_Response_Authenticate();

  Authenticator_Response_Authenticate(const Authenticator_Response_Authenticate& from);

  inline Authenticator_Response_Authenticate& operator=(const Authenticator_Response_Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Authenticate(Authenticator_Response_Authenticate&& from) noexcept
    : Authenticator_Response_Authenticate() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Authenticate& operator=(Authenticator_Response_Authenticate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Authenticate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Authenticate* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Authenticate*>(
               &_Authenticator_Response_Authenticate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(Authenticator_Response_Authenticate* other);
  friend void swap(Authenticator_Response_Authenticate& a, Authenticator_Response_Authenticate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Authenticate* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Authenticate>(NULL);
  }

  Authenticator_Response_Authenticate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Authenticate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Authenticate& from);
  void MergeFrom(const Authenticator_Response_Authenticate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Authenticate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.ACL.Group groups = 4;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 4;
  ::MurmurRPC::ACL_Group* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >*
      mutable_groups();
  const ::MurmurRPC::ACL_Group& groups(int index) const;
  ::MurmurRPC::ACL_Group* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >&
      groups() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .MurmurRPC.Authenticator.Response.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::MurmurRPC::Authenticator_Response_Status status() const;
  void set_status(::MurmurRPC::Authenticator_Response_Status value);

  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Authenticate)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group > groups_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int status_;
  ::google::protobuf::uint32 id_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Find : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Find) */ {
 public:
  Authenticator_Response_Find();
  virtual ~Authenticator_Response_Find();

  Authenticator_Response_Find(const Authenticator_Response_Find& from);

  inline Authenticator_Response_Find& operator=(const Authenticator_Response_Find& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Find(Authenticator_Response_Find&& from) noexcept
    : Authenticator_Response_Find() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Find& operator=(Authenticator_Response_Find&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Find& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Find* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Find*>(
               &_Authenticator_Response_Find_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(Authenticator_Response_Find* other);
  friend void swap(Authenticator_Response_Find& a, Authenticator_Response_Find& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Find* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Find>(NULL);
  }

  Authenticator_Response_Find* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Find>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Find& from);
  void MergeFrom(const Authenticator_Response_Find& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Find* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Find)
 private:
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Query) */ {
 public:
  Authenticator_Response_Query();
  virtual ~Authenticator_Response_Query();

  Authenticator_Response_Query(const Authenticator_Response_Query& from);

  inline Authenticator_Response_Query& operator=(const Authenticator_Response_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Query(Authenticator_Response_Query&& from) noexcept
    : Authenticator_Response_Query() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Query& operator=(Authenticator_Response_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Query* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Query*>(
               &_Authenticator_Response_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(Authenticator_Response_Query* other);
  friend void swap(Authenticator_Response_Query& a, Authenticator_Response_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Query* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Query>(NULL);
  }

  Authenticator_Response_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Query& from);
  void MergeFrom(const Authenticator_Response_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.DatabaseUser users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  ::MurmurRPC::DatabaseUser* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
      mutable_users();
  const ::MurmurRPC::DatabaseUser& users(int index) const;
  ::MurmurRPC::DatabaseUser* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
      users() const;

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser > users_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Register) */ {
 public:
  Authenticator_Response_Register();
  virtual ~Authenticator_Response_Register();

  Authenticator_Response_Register(const Authenticator_Response_Register& from);

  inline Authenticator_Response_Register& operator=(const Authenticator_Response_Register& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Register(Authenticator_Response_Register&& from) noexcept
    : Authenticator_Response_Register() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Register& operator=(Authenticator_Response_Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Register* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Register*>(
               &_Authenticator_Response_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(Authenticator_Response_Register* other);
  friend void swap(Authenticator_Response_Register& a, Authenticator_Response_Register& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Register* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Register>(NULL);
  }

  Authenticator_Response_Register* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Register>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Register& from);
  void MergeFrom(const Authenticator_Response_Register& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.DatabaseUser user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  private:
  const ::MurmurRPC::DatabaseUser& _internal_user() const;
  public:
  const ::MurmurRPC::DatabaseUser& user() const;
  ::MurmurRPC::DatabaseUser* release_user();
  ::MurmurRPC::DatabaseUser* mutable_user();
  void set_allocated_user(::MurmurRPC::DatabaseUser* user);

  // optional .MurmurRPC.Authenticator.Response.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::MurmurRPC::Authenticator_Response_Status status() const;
  void set_status(::MurmurRPC::Authenticator_Response_Status value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Register)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::DatabaseUser* user_;
  int status_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Deregister : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Deregister) */ {
 public:
  Authenticator_Response_Deregister();
  virtual ~Authenticator_Response_Deregister();

  Authenticator_Response_Deregister(const Authenticator_Response_Deregister& from);

  inline Authenticator_Response_Deregister& operator=(const Authenticator_Response_Deregister& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Deregister(Authenticator_Response_Deregister&& from) noexcept
    : Authenticator_Response_Deregister() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Deregister& operator=(Authenticator_Response_Deregister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Deregister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Deregister* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Deregister*>(
               &_Authenticator_Response_Deregister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(Authenticator_Response_Deregister* other);
  friend void swap(Authenticator_Response_Deregister& a, Authenticator_Response_Deregister& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Deregister* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Deregister>(NULL);
  }

  Authenticator_Response_Deregister* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Deregister>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Deregister& from);
  void MergeFrom(const Authenticator_Response_Deregister& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Deregister* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Authenticator.Response.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::MurmurRPC::Authenticator_Response_Status status() const;
  void set_status(::MurmurRPC::Authenticator_Response_Status value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Deregister)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response_Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response.Update) */ {
 public:
  Authenticator_Response_Update();
  virtual ~Authenticator_Response_Update();

  Authenticator_Response_Update(const Authenticator_Response_Update& from);

  inline Authenticator_Response_Update& operator=(const Authenticator_Response_Update& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response_Update(Authenticator_Response_Update&& from) noexcept
    : Authenticator_Response_Update() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response_Update& operator=(Authenticator_Response_Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response_Update& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response_Update* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response_Update*>(
               &_Authenticator_Response_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(Authenticator_Response_Update* other);
  friend void swap(Authenticator_Response_Update& a, Authenticator_Response_Update& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response_Update* New() const final {
    return CreateMaybeMessage<Authenticator_Response_Update>(NULL);
  }

  Authenticator_Response_Update* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response_Update>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response_Update& from);
  void MergeFrom(const Authenticator_Response_Update& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response_Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Authenticator.Response.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::MurmurRPC::Authenticator_Response_Status status() const;
  void set_status(::MurmurRPC::Authenticator_Response_Status value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response.Update)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator.Response) */ {
 public:
  Authenticator_Response();
  virtual ~Authenticator_Response();

  Authenticator_Response(const Authenticator_Response& from);

  inline Authenticator_Response& operator=(const Authenticator_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator_Response(Authenticator_Response&& from) noexcept
    : Authenticator_Response() {
    *this = ::std::move(from);
  }

  inline Authenticator_Response& operator=(Authenticator_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator_Response* internal_default_instance() {
    return reinterpret_cast<const Authenticator_Response*>(
               &_Authenticator_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(Authenticator_Response* other);
  friend void swap(Authenticator_Response& a, Authenticator_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator_Response* New() const final {
    return CreateMaybeMessage<Authenticator_Response>(NULL);
  }

  Authenticator_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator_Response& from);
  void MergeFrom(const Authenticator_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Authenticator_Response_Initialize Initialize;
  typedef Authenticator_Response_Authenticate Authenticate;
  typedef Authenticator_Response_Find Find;
  typedef Authenticator_Response_Query Query;
  typedef Authenticator_Response_Register Register;
  typedef Authenticator_Response_Deregister Deregister;
  typedef Authenticator_Response_Update Update;

  typedef Authenticator_Response_Status Status;
  static const Status Fallthrough =
    Authenticator_Response_Status_Fallthrough;
  static const Status Success =
    Authenticator_Response_Status_Success;
  static const Status Failure =
    Authenticator_Response_Status_Failure;
  static const Status TemporaryFailure =
    Authenticator_Response_Status_TemporaryFailure;
  static inline bool Status_IsValid(int value) {
    return Authenticator_Response_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Authenticator_Response_Status_Status_MIN;
  static const Status Status_MAX =
    Authenticator_Response_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Authenticator_Response_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Authenticator_Response_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Authenticator_Response_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Authenticator_Response_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Authenticator.Response.Initialize initialize = 1;
  bool has_initialize() const;
  void clear_initialize();
  static const int kInitializeFieldNumber = 1;
  private:
  const ::MurmurRPC::Authenticator_Response_Initialize& _internal_initialize() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Initialize& initialize() const;
  ::MurmurRPC::Authenticator_Response_Initialize* release_initialize();
  ::MurmurRPC::Authenticator_Response_Initialize* mutable_initialize();
  void set_allocated_initialize(::MurmurRPC::Authenticator_Response_Initialize* initialize);

  // optional .MurmurRPC.Authenticator.Response.Authenticate authenticate = 2;
  bool has_authenticate() const;
  void clear_authenticate();
  static const int kAuthenticateFieldNumber = 2;
  private:
  const ::MurmurRPC::Authenticator_Response_Authenticate& _internal_authenticate() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Authenticate& authenticate() const;
  ::MurmurRPC::Authenticator_Response_Authenticate* release_authenticate();
  ::MurmurRPC::Authenticator_Response_Authenticate* mutable_authenticate();
  void set_allocated_authenticate(::MurmurRPC::Authenticator_Response_Authenticate* authenticate);

  // optional .MurmurRPC.Authenticator.Response.Find find = 3;
  bool has_find() const;
  void clear_find();
  static const int kFindFieldNumber = 3;
  private:
  const ::MurmurRPC::Authenticator_Response_Find& _internal_find() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Find& find() const;
  ::MurmurRPC::Authenticator_Response_Find* release_find();
  ::MurmurRPC::Authenticator_Response_Find* mutable_find();
  void set_allocated_find(::MurmurRPC::Authenticator_Response_Find* find);

  // optional .MurmurRPC.Authenticator.Response.Query query = 4;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 4;
  private:
  const ::MurmurRPC::Authenticator_Response_Query& _internal_query() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Query& query() const;
  ::MurmurRPC::Authenticator_Response_Query* release_query();
  ::MurmurRPC::Authenticator_Response_Query* mutable_query();
  void set_allocated_query(::MurmurRPC::Authenticator_Response_Query* query);

  // optional .MurmurRPC.Authenticator.Response.Register register = 5;
  bool has_register_() const;
  void clear_register_();
  static const int kRegisterFieldNumber = 5;
  private:
  const ::MurmurRPC::Authenticator_Response_Register& _internal_register_() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Register& register_() const;
  ::MurmurRPC::Authenticator_Response_Register* release_register_();
  ::MurmurRPC::Authenticator_Response_Register* mutable_register_();
  void set_allocated_register_(::MurmurRPC::Authenticator_Response_Register* register_);

  // optional .MurmurRPC.Authenticator.Response.Deregister deregister = 6;
  bool has_deregister() const;
  void clear_deregister();
  static const int kDeregisterFieldNumber = 6;
  private:
  const ::MurmurRPC::Authenticator_Response_Deregister& _internal_deregister() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Deregister& deregister() const;
  ::MurmurRPC::Authenticator_Response_Deregister* release_deregister();
  ::MurmurRPC::Authenticator_Response_Deregister* mutable_deregister();
  void set_allocated_deregister(::MurmurRPC::Authenticator_Response_Deregister* deregister);

  // optional .MurmurRPC.Authenticator.Response.Update update = 7;
  bool has_update() const;
  void clear_update();
  static const int kUpdateFieldNumber = 7;
  private:
  const ::MurmurRPC::Authenticator_Response_Update& _internal_update() const;
  public:
  const ::MurmurRPC::Authenticator_Response_Update& update() const;
  ::MurmurRPC::Authenticator_Response_Update* release_update();
  ::MurmurRPC::Authenticator_Response_Update* mutable_update();
  void set_allocated_update(::MurmurRPC::Authenticator_Response_Update* update);

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator.Response)
 private:
  void set_has_initialize();
  void clear_has_initialize();
  void set_has_authenticate();
  void clear_has_authenticate();
  void set_has_find();
  void clear_has_find();
  void set_has_query();
  void clear_has_query();
  void set_has_register_();
  void clear_has_register_();
  void set_has_deregister();
  void clear_has_deregister();
  void set_has_update();
  void clear_has_update();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Authenticator_Response_Initialize* initialize_;
  ::MurmurRPC::Authenticator_Response_Authenticate* authenticate_;
  ::MurmurRPC::Authenticator_Response_Find* find_;
  ::MurmurRPC::Authenticator_Response_Query* query_;
  ::MurmurRPC::Authenticator_Response_Register* register__;
  ::MurmurRPC::Authenticator_Response_Deregister* deregister_;
  ::MurmurRPC::Authenticator_Response_Update* update_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Authenticator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.Authenticator) */ {
 public:
  Authenticator();
  virtual ~Authenticator();

  Authenticator(const Authenticator& from);

  inline Authenticator& operator=(const Authenticator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticator(Authenticator&& from) noexcept
    : Authenticator() {
    *this = ::std::move(from);
  }

  inline Authenticator& operator=(Authenticator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticator* internal_default_instance() {
    return reinterpret_cast<const Authenticator*>(
               &_Authenticator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(Authenticator* other);
  friend void swap(Authenticator& a, Authenticator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticator* New() const final {
    return CreateMaybeMessage<Authenticator>(NULL);
  }

  Authenticator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticator& from);
  void MergeFrom(const Authenticator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Authenticator_Request Request;
  typedef Authenticator_Response Response;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MurmurRPC.Authenticator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DatabaseUser_Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.DatabaseUser.Query) */ {
 public:
  DatabaseUser_Query();
  virtual ~DatabaseUser_Query();

  DatabaseUser_Query(const DatabaseUser_Query& from);

  inline DatabaseUser_Query& operator=(const DatabaseUser_Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatabaseUser_Query(DatabaseUser_Query&& from) noexcept
    : DatabaseUser_Query() {
    *this = ::std::move(from);
  }

  inline DatabaseUser_Query& operator=(DatabaseUser_Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseUser_Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabaseUser_Query* internal_default_instance() {
    return reinterpret_cast<const DatabaseUser_Query*>(
               &_DatabaseUser_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(DatabaseUser_Query* other);
  friend void swap(DatabaseUser_Query& a, DatabaseUser_Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatabaseUser_Query* New() const final {
    return CreateMaybeMessage<DatabaseUser_Query>(NULL);
  }

  DatabaseUser_Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatabaseUser_Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatabaseUser_Query& from);
  void MergeFrom(const DatabaseUser_Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseUser_Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.DatabaseUser.Query)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_filter();
  void clear_has_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DatabaseUser_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.DatabaseUser.List) */ {
 public:
  DatabaseUser_List();
  virtual ~DatabaseUser_List();

  DatabaseUser_List(const DatabaseUser_List& from);

  inline DatabaseUser_List& operator=(const DatabaseUser_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatabaseUser_List(DatabaseUser_List&& from) noexcept
    : DatabaseUser_List() {
    *this = ::std::move(from);
  }

  inline DatabaseUser_List& operator=(DatabaseUser_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseUser_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabaseUser_List* internal_default_instance() {
    return reinterpret_cast<const DatabaseUser_List*>(
               &_DatabaseUser_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(DatabaseUser_List* other);
  friend void swap(DatabaseUser_List& a, DatabaseUser_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatabaseUser_List* New() const final {
    return CreateMaybeMessage<DatabaseUser_List>(NULL);
  }

  DatabaseUser_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatabaseUser_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatabaseUser_List& from);
  void MergeFrom(const DatabaseUser_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseUser_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MurmurRPC.DatabaseUser users = 2;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  ::MurmurRPC::DatabaseUser* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
      mutable_users();
  const ::MurmurRPC::DatabaseUser& users(int index) const;
  ::MurmurRPC::DatabaseUser* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
      users() const;

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.DatabaseUser.List)
 private:
  void set_has_server();
  void clear_has_server();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser > users_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DatabaseUser_Verify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.DatabaseUser.Verify) */ {
 public:
  DatabaseUser_Verify();
  virtual ~DatabaseUser_Verify();

  DatabaseUser_Verify(const DatabaseUser_Verify& from);

  inline DatabaseUser_Verify& operator=(const DatabaseUser_Verify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatabaseUser_Verify(DatabaseUser_Verify&& from) noexcept
    : DatabaseUser_Verify() {
    *this = ::std::move(from);
  }

  inline DatabaseUser_Verify& operator=(DatabaseUser_Verify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseUser_Verify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabaseUser_Verify* internal_default_instance() {
    return reinterpret_cast<const DatabaseUser_Verify*>(
               &_DatabaseUser_Verify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(DatabaseUser_Verify* other);
  friend void swap(DatabaseUser_Verify& a, DatabaseUser_Verify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatabaseUser_Verify* New() const final {
    return CreateMaybeMessage<DatabaseUser_Verify>(NULL);
  }

  DatabaseUser_Verify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatabaseUser_Verify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatabaseUser_Verify& from);
  void MergeFrom(const DatabaseUser_Verify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseUser_Verify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // @@protoc_insertion_point(class_scope:MurmurRPC.DatabaseUser.Verify)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_name();
  void clear_has_name();
  void set_has_password();
  void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::MurmurRPC::Server* server_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DatabaseUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.DatabaseUser) */ {
 public:
  DatabaseUser();
  virtual ~DatabaseUser();

  DatabaseUser(const DatabaseUser& from);

  inline DatabaseUser& operator=(const DatabaseUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatabaseUser(DatabaseUser&& from) noexcept
    : DatabaseUser() {
    *this = ::std::move(from);
  }

  inline DatabaseUser& operator=(DatabaseUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabaseUser* internal_default_instance() {
    return reinterpret_cast<const DatabaseUser*>(
               &_DatabaseUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(DatabaseUser* other);
  friend void swap(DatabaseUser& a, DatabaseUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatabaseUser* New() const final {
    return CreateMaybeMessage<DatabaseUser>(NULL);
  }

  DatabaseUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatabaseUser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatabaseUser& from);
  void MergeFrom(const DatabaseUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DatabaseUser_Query Query;
  typedef DatabaseUser_List List;
  typedef DatabaseUser_Verify Verify;

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string email = 4;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 4;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string comment = 5;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 5;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional string hash = 6;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 6;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string password = 7;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 7;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string last_active = 8;
  bool has_last_active() const;
  void clear_last_active();
  static const int kLastActiveFieldNumber = 8;
  const ::std::string& last_active() const;
  void set_last_active(const ::std::string& value);
  #if LANG_CXX11
  void set_last_active(::std::string&& value);
  #endif
  void set_last_active(const char* value);
  void set_last_active(const char* value, size_t size);
  ::std::string* mutable_last_active();
  ::std::string* release_last_active();
  void set_allocated_last_active(::std::string* last_active);

  // optional bytes texture = 9;
  bool has_texture() const;
  void clear_texture();
  static const int kTextureFieldNumber = 9;
  const ::std::string& texture() const;
  void set_texture(const ::std::string& value);
  #if LANG_CXX11
  void set_texture(::std::string&& value);
  #endif
  void set_texture(const char* value);
  void set_texture(const void* value, size_t size);
  ::std::string* mutable_texture();
  ::std::string* release_texture();
  void set_allocated_texture(::std::string* texture);

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MurmurRPC.DatabaseUser)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_email();
  void clear_has_email();
  void set_has_comment();
  void clear_has_comment();
  void set_has_hash();
  void clear_has_hash();
  void set_has_password();
  void clear_has_password();
  void set_has_last_active();
  void clear_has_last_active();
  void set_has_texture();
  void clear_has_texture();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr last_active_;
  ::google::protobuf::internal::ArenaStringPtr texture_;
  ::MurmurRPC::Server* server_;
  ::google::protobuf::uint32 id_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedirectWhisperGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MurmurRPC.RedirectWhisperGroup) */ {
 public:
  RedirectWhisperGroup();
  virtual ~RedirectWhisperGroup();

  RedirectWhisperGroup(const RedirectWhisperGroup& from);

  inline RedirectWhisperGroup& operator=(const RedirectWhisperGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectWhisperGroup(RedirectWhisperGroup&& from) noexcept
    : RedirectWhisperGroup() {
    *this = ::std::move(from);
  }

  inline RedirectWhisperGroup& operator=(RedirectWhisperGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectWhisperGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RedirectWhisperGroup* internal_default_instance() {
    return reinterpret_cast<const RedirectWhisperGroup*>(
               &_RedirectWhisperGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(RedirectWhisperGroup* other);
  friend void swap(RedirectWhisperGroup& a, RedirectWhisperGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectWhisperGroup* New() const final {
    return CreateMaybeMessage<RedirectWhisperGroup>(NULL);
  }

  RedirectWhisperGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RedirectWhisperGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RedirectWhisperGroup& from);
  void MergeFrom(const RedirectWhisperGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedirectWhisperGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MurmurRPC.Server server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  private:
  const ::MurmurRPC::Server& _internal_server() const;
  public:
  const ::MurmurRPC::Server& server() const;
  ::MurmurRPC::Server* release_server();
  ::MurmurRPC::Server* mutable_server();
  void set_allocated_server(::MurmurRPC::Server* server);

  // optional .MurmurRPC.User user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  private:
  const ::MurmurRPC::User& _internal_user() const;
  public:
  const ::MurmurRPC::User& user() const;
  ::MurmurRPC::User* release_user();
  ::MurmurRPC::User* mutable_user();
  void set_allocated_user(::MurmurRPC::User* user);

  // optional .MurmurRPC.ACL.Group source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  private:
  const ::MurmurRPC::ACL_Group& _internal_source() const;
  public:
  const ::MurmurRPC::ACL_Group& source() const;
  ::MurmurRPC::ACL_Group* release_source();
  ::MurmurRPC::ACL_Group* mutable_source();
  void set_allocated_source(::MurmurRPC::ACL_Group* source);

  // optional .MurmurRPC.ACL.Group target = 4;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  private:
  const ::MurmurRPC::ACL_Group& _internal_target() const;
  public:
  const ::MurmurRPC::ACL_Group& target() const;
  ::MurmurRPC::ACL_Group* release_target();
  ::MurmurRPC::ACL_Group* mutable_target();
  void set_allocated_target(::MurmurRPC::ACL_Group* target);

  // @@protoc_insertion_point(class_scope:MurmurRPC.RedirectWhisperGroup)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_user();
  void clear_has_user();
  void set_has_source();
  void clear_has_source();
  void set_has_target();
  void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MurmurRPC::Server* server_;
  ::MurmurRPC::User* user_;
  ::MurmurRPC::ACL_Group* source_;
  ::MurmurRPC::ACL_Group* target_;
  friend struct ::protobuf_MurmurRPC_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Void

// -------------------------------------------------------------------

// Version

// optional uint32 version = 1;
inline bool Version::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Version::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Version::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Version::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Version::version() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Version.version)
  return version_;
}
inline void Version::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Version.version)
}

// optional string release = 2;
inline bool Version::has_release() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_release() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_release() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& Version::release() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Version.release)
  return release_.GetNoArena();
}
inline void Version::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Version.release)
}
#if LANG_CXX11
inline void Version::set_release(::std::string&& value) {
  set_has_release();
  release_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Version.release)
}
#endif
inline void Version::set_release(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Version.release)
}
inline void Version::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Version.release)
}
inline ::std::string* Version::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Version.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_release() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Version.release)
  if (!has_release()) {
    return NULL;
  }
  clear_has_release();
  return release_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Version.release)
}

// optional string os = 3;
inline bool Version::has_os() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_os() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_os() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os();
}
inline const ::std::string& Version::os() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Version.os)
  return os_.GetNoArena();
}
inline void Version::set_os(const ::std::string& value) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Version.os)
}
#if LANG_CXX11
inline void Version::set_os(::std::string&& value) {
  set_has_os();
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Version.os)
}
#endif
inline void Version::set_os(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Version.os)
}
inline void Version::set_os(const char* value, size_t size) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Version.os)
}
inline ::std::string* Version::mutable_os() {
  set_has_os();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Version.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Version.os)
  if (!has_os()) {
    return NULL;
  }
  clear_has_os();
  return os_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os(::std::string* os) {
  if (os != NULL) {
    set_has_os();
  } else {
    clear_has_os();
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Version.os)
}

// optional string os_version = 4;
inline bool Version::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_version();
}
inline const ::std::string& Version::os_version() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Version.os_version)
  return os_version_.GetNoArena();
}
inline void Version::set_os_version(const ::std::string& value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Version.os_version)
}
#if LANG_CXX11
inline void Version::set_os_version(::std::string&& value) {
  set_has_os_version();
  os_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Version.os_version)
}
#endif
inline void Version::set_os_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Version.os_version)
}
inline void Version::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Version.os_version)
}
inline ::std::string* Version::mutable_os_version() {
  set_has_os_version();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Version.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os_version() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Version.os_version)
  if (!has_os_version()) {
    return NULL;
  }
  clear_has_os_version();
  return os_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    set_has_os_version();
  } else {
    clear_has_os_version();
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Version.os_version)
}

// -------------------------------------------------------------------

// Uptime

// optional uint64 secs = 1;
inline bool Uptime::has_secs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uptime::set_has_secs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uptime::clear_has_secs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uptime::clear_secs() {
  secs_ = GOOGLE_ULONGLONG(0);
  clear_has_secs();
}
inline ::google::protobuf::uint64 Uptime::secs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Uptime.secs)
  return secs_;
}
inline void Uptime::set_secs(::google::protobuf::uint64 value) {
  set_has_secs();
  secs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Uptime.secs)
}

// -------------------------------------------------------------------

// Server_Event

// optional .MurmurRPC.Server server = 1;
inline bool Server_Event::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Server_Event::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Server_Event::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Server_Event::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Server_Event::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Server_Event::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.Event.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Server_Event::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Server.Event.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Server_Event::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.Event.server)
  return server_;
}
inline void Server_Event::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Server.Event.server)
}

// optional .MurmurRPC.Server.Event.Type type = 2;
inline bool Server_Event::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Server_Event::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Server_Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Server_Event::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MurmurRPC::Server_Event_Type Server_Event::type() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.Event.type)
  return static_cast< ::MurmurRPC::Server_Event_Type >(type_);
}
inline void Server_Event::set_type(::MurmurRPC::Server_Event_Type value) {
  assert(::MurmurRPC::Server_Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Server.Event.type)
}

// optional .MurmurRPC.User user = 3;
inline bool Server_Event::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Server_Event::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Server_Event::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Server_Event::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& Server_Event::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& Server_Event::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.Event.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* Server_Event::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Server.Event.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* Server_Event::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.Event.user)
  return user_;
}
inline void Server_Event::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Server.Event.user)
}

// optional .MurmurRPC.TextMessage message = 4;
inline bool Server_Event::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Server_Event::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Server_Event::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Server_Event::clear_message() {
  if (message_ != NULL) message_->Clear();
  clear_has_message();
}
inline const ::MurmurRPC::TextMessage& Server_Event::_internal_message() const {
  return *message_;
}
inline const ::MurmurRPC::TextMessage& Server_Event::message() const {
  const ::MurmurRPC::TextMessage* p = message_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.Event.message)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::TextMessage*>(
      &::MurmurRPC::_TextMessage_default_instance_);
}
inline ::MurmurRPC::TextMessage* Server_Event::release_message() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Server.Event.message)
  clear_has_message();
  ::MurmurRPC::TextMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline ::MurmurRPC::TextMessage* Server_Event::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::TextMessage>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.Event.message)
  return message_;
}
inline void Server_Event::set_allocated_message(::MurmurRPC::TextMessage* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete message_;
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
  } else {
    clear_has_message();
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Server.Event.message)
}

// optional .MurmurRPC.Channel channel = 5;
inline bool Server_Event::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Server_Event::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Server_Event::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Server_Event::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& Server_Event::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& Server_Event::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.Event.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* Server_Event::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Server.Event.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* Server_Event::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.Event.channel)
  return channel_;
}
inline void Server_Event::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Server.Event.channel)
}

// -------------------------------------------------------------------

// Server_Query

// -------------------------------------------------------------------

// Server_List

// repeated .MurmurRPC.Server servers = 1;
inline int Server_List::servers_size() const {
  return servers_.size();
}
inline void Server_List::clear_servers() {
  servers_.Clear();
}
inline ::MurmurRPC::Server* Server_List::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.List.servers)
  return servers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Server >*
Server_List::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Server.List.servers)
  return &servers_;
}
inline const ::MurmurRPC::Server& Server_List::servers(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.List.servers)
  return servers_.Get(index);
}
inline ::MurmurRPC::Server* Server_List::add_servers() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Server.List.servers)
  return servers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Server >&
Server_List::servers() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Server.List.servers)
  return servers_;
}

// -------------------------------------------------------------------

// Server

// required uint32 id = 1;
inline bool Server::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Server::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Server::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Server::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Server::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.id)
  return id_;
}
inline void Server::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Server.id)
}

// optional bool running = 2;
inline bool Server::has_running() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Server::set_has_running() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Server::clear_has_running() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Server::clear_running() {
  running_ = false;
  clear_has_running();
}
inline bool Server::running() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.running)
  return running_;
}
inline void Server::set_running(bool value) {
  set_has_running();
  running_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Server.running)
}

// optional .MurmurRPC.Uptime uptime = 3;
inline bool Server::has_uptime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Server::set_has_uptime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Server::clear_has_uptime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Server::clear_uptime() {
  if (uptime_ != NULL) uptime_->Clear();
  clear_has_uptime();
}
inline const ::MurmurRPC::Uptime& Server::_internal_uptime() const {
  return *uptime_;
}
inline const ::MurmurRPC::Uptime& Server::uptime() const {
  const ::MurmurRPC::Uptime* p = uptime_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Server.uptime)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Uptime*>(
      &::MurmurRPC::_Uptime_default_instance_);
}
inline ::MurmurRPC::Uptime* Server::release_uptime() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Server.uptime)
  clear_has_uptime();
  ::MurmurRPC::Uptime* temp = uptime_;
  uptime_ = NULL;
  return temp;
}
inline ::MurmurRPC::Uptime* Server::mutable_uptime() {
  set_has_uptime();
  if (uptime_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Uptime>(GetArenaNoVirtual());
    uptime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Server.uptime)
  return uptime_;
}
inline void Server::set_allocated_uptime(::MurmurRPC::Uptime* uptime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uptime_;
  }
  if (uptime) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uptime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uptime, submessage_arena);
    }
    set_has_uptime();
  } else {
    clear_has_uptime();
  }
  uptime_ = uptime;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Server.uptime)
}

// -------------------------------------------------------------------

// Event

// optional .MurmurRPC.Server server = 1;
inline bool Event::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Event::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Event::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Event.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Event::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Event.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Event::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Event.server)
  return server_;
}
inline void Event::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Event.server)
}

// optional .MurmurRPC.Event.Type type = 2;
inline bool Event::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MurmurRPC::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Event.type)
  return static_cast< ::MurmurRPC::Event_Type >(type_);
}
inline void Event::set_type(::MurmurRPC::Event_Type value) {
  assert(::MurmurRPC::Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Event.type)
}

// -------------------------------------------------------------------

// ContextAction

// optional .MurmurRPC.Server server = 1;
inline bool ContextAction::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextAction::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContextAction::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContextAction::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& ContextAction::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& ContextAction::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* ContextAction::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* ContextAction::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.server)
  return server_;
}
inline void ContextAction::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.server)
}

// optional uint32 context = 2;
inline bool ContextAction::has_context() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContextAction::set_has_context() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContextAction::clear_has_context() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContextAction::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 ContextAction::context() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.context)
  return context_;
}
inline void ContextAction::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ContextAction.context)
}

// optional string action = 3;
inline bool ContextAction::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextAction::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContextAction::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContextAction::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_action();
}
inline const ::std::string& ContextAction::action() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.action)
  return action_.GetNoArena();
}
inline void ContextAction::set_action(const ::std::string& value) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.ContextAction.action)
}
#if LANG_CXX11
inline void ContextAction::set_action(::std::string&& value) {
  set_has_action();
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.ContextAction.action)
}
#endif
inline void ContextAction::set_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.ContextAction.action)
}
inline void ContextAction::set_action(const char* value, size_t size) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.ContextAction.action)
}
inline ::std::string* ContextAction::mutable_action() {
  set_has_action();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextAction::release_action() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.action)
  if (!has_action()) {
    return NULL;
  }
  clear_has_action();
  return action_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextAction::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    set_has_action();
  } else {
    clear_has_action();
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.action)
}

// optional string text = 4;
inline bool ContextAction::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextAction::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContextAction::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContextAction::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& ContextAction::text() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.text)
  return text_.GetNoArena();
}
inline void ContextAction::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.ContextAction.text)
}
#if LANG_CXX11
inline void ContextAction::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.ContextAction.text)
}
#endif
inline void ContextAction::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.ContextAction.text)
}
inline void ContextAction::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.ContextAction.text)
}
inline ::std::string* ContextAction::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextAction::release_text() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextAction::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.text)
}

// optional .MurmurRPC.User actor = 5;
inline bool ContextAction::has_actor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContextAction::set_has_actor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContextAction::clear_has_actor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContextAction::clear_actor() {
  if (actor_ != NULL) actor_->Clear();
  clear_has_actor();
}
inline const ::MurmurRPC::User& ContextAction::_internal_actor() const {
  return *actor_;
}
inline const ::MurmurRPC::User& ContextAction::actor() const {
  const ::MurmurRPC::User* p = actor_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.actor)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* ContextAction::release_actor() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.actor)
  clear_has_actor();
  ::MurmurRPC::User* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* ContextAction::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    actor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.actor)
  return actor_;
}
inline void ContextAction::set_allocated_actor(::MurmurRPC::User* actor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_;
  }
  if (actor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor, submessage_arena);
    }
    set_has_actor();
  } else {
    clear_has_actor();
  }
  actor_ = actor;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.actor)
}

// optional .MurmurRPC.User user = 6;
inline bool ContextAction::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContextAction::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContextAction::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContextAction::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& ContextAction::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& ContextAction::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* ContextAction::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* ContextAction::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.user)
  return user_;
}
inline void ContextAction::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.user)
}

// optional .MurmurRPC.Channel channel = 7;
inline bool ContextAction::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContextAction::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContextAction::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContextAction::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& ContextAction::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& ContextAction::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ContextAction.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* ContextAction::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ContextAction.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* ContextAction::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ContextAction.channel)
  return channel_;
}
inline void ContextAction::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ContextAction.channel)
}

// -------------------------------------------------------------------

// TextMessage_Filter

// optional .MurmurRPC.Server server = 1;
inline bool TextMessage_Filter::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMessage_Filter::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextMessage_Filter::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextMessage_Filter::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& TextMessage_Filter::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& TextMessage_Filter::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.Filter.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* TextMessage_Filter::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.TextMessage.Filter.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* TextMessage_Filter::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.Filter.server)
  return server_;
}
inline void TextMessage_Filter::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.TextMessage.Filter.server)
}

// optional .MurmurRPC.TextMessage.Filter.Action action = 2;
inline bool TextMessage_Filter::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextMessage_Filter::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextMessage_Filter::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextMessage_Filter::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::MurmurRPC::TextMessage_Filter_Action TextMessage_Filter::action() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.Filter.action)
  return static_cast< ::MurmurRPC::TextMessage_Filter_Action >(action_);
}
inline void TextMessage_Filter::set_action(::MurmurRPC::TextMessage_Filter_Action value) {
  assert(::MurmurRPC::TextMessage_Filter_Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.TextMessage.Filter.action)
}

// optional .MurmurRPC.TextMessage message = 3;
inline bool TextMessage_Filter::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMessage_Filter::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextMessage_Filter::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextMessage_Filter::clear_message() {
  if (message_ != NULL) message_->Clear();
  clear_has_message();
}
inline const ::MurmurRPC::TextMessage& TextMessage_Filter::_internal_message() const {
  return *message_;
}
inline const ::MurmurRPC::TextMessage& TextMessage_Filter::message() const {
  const ::MurmurRPC::TextMessage* p = message_;
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.Filter.message)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::TextMessage*>(
      &::MurmurRPC::_TextMessage_default_instance_);
}
inline ::MurmurRPC::TextMessage* TextMessage_Filter::release_message() {
  // @@protoc_insertion_point(field_release:MurmurRPC.TextMessage.Filter.message)
  clear_has_message();
  ::MurmurRPC::TextMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline ::MurmurRPC::TextMessage* TextMessage_Filter::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::TextMessage>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.Filter.message)
  return message_;
}
inline void TextMessage_Filter::set_allocated_message(::MurmurRPC::TextMessage* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete message_;
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
  } else {
    clear_has_message();
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.TextMessage.Filter.message)
}

// -------------------------------------------------------------------

// TextMessage

// optional .MurmurRPC.Server server = 1;
inline bool TextMessage::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMessage::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextMessage::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextMessage::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& TextMessage::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& TextMessage::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* TextMessage::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.TextMessage.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* TextMessage::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.server)
  return server_;
}
inline void TextMessage::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.TextMessage.server)
}

// optional .MurmurRPC.User actor = 2;
inline bool TextMessage::has_actor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextMessage::set_has_actor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextMessage::clear_has_actor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextMessage::clear_actor() {
  if (actor_ != NULL) actor_->Clear();
  clear_has_actor();
}
inline const ::MurmurRPC::User& TextMessage::_internal_actor() const {
  return *actor_;
}
inline const ::MurmurRPC::User& TextMessage::actor() const {
  const ::MurmurRPC::User* p = actor_;
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.actor)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* TextMessage::release_actor() {
  // @@protoc_insertion_point(field_release:MurmurRPC.TextMessage.actor)
  clear_has_actor();
  ::MurmurRPC::User* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* TextMessage::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    actor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.actor)
  return actor_;
}
inline void TextMessage::set_allocated_actor(::MurmurRPC::User* actor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_;
  }
  if (actor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor, submessage_arena);
    }
    set_has_actor();
  } else {
    clear_has_actor();
  }
  actor_ = actor;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.TextMessage.actor)
}

// repeated .MurmurRPC.User users = 3;
inline int TextMessage::users_size() const {
  return users_.size();
}
inline void TextMessage::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::User* TextMessage::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
TextMessage::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.TextMessage.users)
  return &users_;
}
inline const ::MurmurRPC::User& TextMessage::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.users)
  return users_.Get(index);
}
inline ::MurmurRPC::User* TextMessage::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.TextMessage.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
TextMessage::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.TextMessage.users)
  return users_;
}

// repeated .MurmurRPC.Channel channels = 4;
inline int TextMessage::channels_size() const {
  return channels_.size();
}
inline void TextMessage::clear_channels() {
  channels_.Clear();
}
inline ::MurmurRPC::Channel* TextMessage::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.channels)
  return channels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
TextMessage::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.TextMessage.channels)
  return &channels_;
}
inline const ::MurmurRPC::Channel& TextMessage::channels(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.channels)
  return channels_.Get(index);
}
inline ::MurmurRPC::Channel* TextMessage::add_channels() {
  // @@protoc_insertion_point(field_add:MurmurRPC.TextMessage.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
TextMessage::channels() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.TextMessage.channels)
  return channels_;
}

// repeated .MurmurRPC.Channel trees = 5;
inline int TextMessage::trees_size() const {
  return trees_.size();
}
inline void TextMessage::clear_trees() {
  trees_.Clear();
}
inline ::MurmurRPC::Channel* TextMessage::mutable_trees(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.trees)
  return trees_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
TextMessage::mutable_trees() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.TextMessage.trees)
  return &trees_;
}
inline const ::MurmurRPC::Channel& TextMessage::trees(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.trees)
  return trees_.Get(index);
}
inline ::MurmurRPC::Channel* TextMessage::add_trees() {
  // @@protoc_insertion_point(field_add:MurmurRPC.TextMessage.trees)
  return trees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
TextMessage::trees() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.TextMessage.trees)
  return trees_;
}

// optional string text = 6;
inline bool TextMessage::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMessage::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextMessage::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextMessage::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& TextMessage::text() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.TextMessage.text)
  return text_.GetNoArena();
}
inline void TextMessage::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.TextMessage.text)
}
#if LANG_CXX11
inline void TextMessage::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.TextMessage.text)
}
#endif
inline void TextMessage::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.TextMessage.text)
}
inline void TextMessage::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.TextMessage.text)
}
inline ::std::string* TextMessage::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.TextMessage.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextMessage::release_text() {
  // @@protoc_insertion_point(field_release:MurmurRPC.TextMessage.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.TextMessage.text)
}

// -------------------------------------------------------------------

// Log_Query

// optional .MurmurRPC.Server server = 1;
inline bool Log_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Log_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Log_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Log_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Log.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Log_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Log.Query.server)
  return server_;
}
inline void Log_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Log.Query.server)
}

// optional uint32 min = 2;
inline bool Log_Query::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log_Query::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log_Query::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log_Query::clear_min() {
  min_ = 0u;
  clear_has_min();
}
inline ::google::protobuf::uint32 Log_Query::min() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.Query.min)
  return min_;
}
inline void Log_Query::set_min(::google::protobuf::uint32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.Query.min)
}

// optional uint32 max = 3;
inline bool Log_Query::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log_Query::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log_Query::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log_Query::clear_max() {
  max_ = 0u;
  clear_has_max();
}
inline ::google::protobuf::uint32 Log_Query::max() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.Query.max)
  return max_;
}
inline void Log_Query::set_max(::google::protobuf::uint32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.Query.max)
}

// -------------------------------------------------------------------

// Log_List

// optional .MurmurRPC.Server server = 1;
inline bool Log_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Log_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Log_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Log_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Log.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Log_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Log.List.server)
  return server_;
}
inline void Log_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Log.List.server)
}

// optional uint32 total = 2;
inline bool Log_List::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log_List::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log_List::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log_List::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 Log_List::total() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.List.total)
  return total_;
}
inline void Log_List::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.List.total)
}

// optional uint32 min = 3;
inline bool Log_List::has_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log_List::set_has_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log_List::clear_has_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log_List::clear_min() {
  min_ = 0u;
  clear_has_min();
}
inline ::google::protobuf::uint32 Log_List::min() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.List.min)
  return min_;
}
inline void Log_List::set_min(::google::protobuf::uint32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.List.min)
}

// optional uint32 max = 4;
inline bool Log_List::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Log_List::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Log_List::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Log_List::clear_max() {
  max_ = 0u;
  clear_has_max();
}
inline ::google::protobuf::uint32 Log_List::max() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.List.max)
  return max_;
}
inline void Log_List::set_max(::google::protobuf::uint32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.List.max)
}

// repeated .MurmurRPC.Log entries = 5;
inline int Log_List::entries_size() const {
  return entries_.size();
}
inline void Log_List::clear_entries() {
  entries_.Clear();
}
inline ::MurmurRPC::Log* Log_List::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Log.List.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Log >*
Log_List::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Log.List.entries)
  return &entries_;
}
inline const ::MurmurRPC::Log& Log_List::entries(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.List.entries)
  return entries_.Get(index);
}
inline ::MurmurRPC::Log* Log_List::add_entries() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Log.List.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Log >&
Log_List::entries() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Log.List.entries)
  return entries_;
}

// -------------------------------------------------------------------

// Log

// optional .MurmurRPC.Server server = 1;
inline bool Log::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Log::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Log::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Log::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Log.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Log::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Log.server)
  return server_;
}
inline void Log::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Log.server)
}

// optional int64 timestamp = 2;
inline bool Log::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Log::timestamp() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.timestamp)
  return timestamp_;
}
inline void Log::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.timestamp)
}

// optional string text = 3;
inline bool Log::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Log::text() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Log.text)
  return text_.GetNoArena();
}
inline void Log::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Log.text)
}
#if LANG_CXX11
inline void Log::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Log.text)
}
#endif
inline void Log::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Log.text)
}
inline void Log::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Log.text)
}
inline ::std::string* Log::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Log.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_text() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Log.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Log.text)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Config_Field

// optional .MurmurRPC.Server server = 1;
inline bool Config_Field::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config_Field::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config_Field::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config_Field::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Config_Field::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Config_Field::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Config.Field.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Config_Field::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Config.Field.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Config_Field::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Config.Field.server)
  return server_;
}
inline void Config_Field::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Config.Field.server)
}

// optional string key = 2;
inline bool Config_Field::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config_Field::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config_Field::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config_Field::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Config_Field::key() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Config.Field.key)
  return key_.GetNoArena();
}
inline void Config_Field::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Config.Field.key)
}
#if LANG_CXX11
inline void Config_Field::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Config.Field.key)
}
#endif
inline void Config_Field::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Config.Field.key)
}
inline void Config_Field::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Config.Field.key)
}
inline ::std::string* Config_Field::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Config.Field.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config_Field::release_key() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Config.Field.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config_Field::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Config.Field.key)
}

// optional string value = 3;
inline bool Config_Field::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config_Field::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config_Field::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config_Field::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Config_Field::value() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Config.Field.value)
  return value_.GetNoArena();
}
inline void Config_Field::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Config.Field.value)
}
#if LANG_CXX11
inline void Config_Field::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Config.Field.value)
}
#endif
inline void Config_Field::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Config.Field.value)
}
inline void Config_Field::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Config.Field.value)
}
inline ::std::string* Config_Field::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Config.Field.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config_Field::release_value() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Config.Field.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config_Field::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Config.Field.value)
}

// -------------------------------------------------------------------

// Config

// optional .MurmurRPC.Server server = 1;
inline bool Config::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Config::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Config::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Config.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Config::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Config.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Config::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Config.server)
  return server_;
}
inline void Config::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Config.server)
}

// map<string, string> fields = 2;
inline int Config::fields_size() const {
  return fields_.size();
}
inline void Config::clear_fields() {
  fields_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Config::fields() const {
  // @@protoc_insertion_point(field_map:MurmurRPC.Config.fields)
  return fields_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Config::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_map:MurmurRPC.Config.fields)
  return fields_.MutableMap();
}

// -------------------------------------------------------------------

// Channel_Query

// optional .MurmurRPC.Server server = 1;
inline bool Channel_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Channel_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Channel_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Channel_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Channel_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.Query.server)
  return server_;
}
inline void Channel_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.Query.server)
}

// -------------------------------------------------------------------

// Channel_List

// optional .MurmurRPC.Server server = 1;
inline bool Channel_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Channel_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Channel_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Channel_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Channel_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.List.server)
  return server_;
}
inline void Channel_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.List.server)
}

// repeated .MurmurRPC.Channel channels = 2;
inline int Channel_List::channels_size() const {
  return channels_.size();
}
inline void Channel_List::clear_channels() {
  channels_.Clear();
}
inline ::MurmurRPC::Channel* Channel_List::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.List.channels)
  return channels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
Channel_List::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Channel.List.channels)
  return &channels_;
}
inline const ::MurmurRPC::Channel& Channel_List::channels(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.List.channels)
  return channels_.Get(index);
}
inline ::MurmurRPC::Channel* Channel_List::add_channels() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Channel.List.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
Channel_List::channels() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Channel.List.channels)
  return channels_;
}

// -------------------------------------------------------------------

// Channel

// optional .MurmurRPC.Server server = 1;
inline bool Channel::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Channel::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Channel::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Channel::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Channel::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.server)
  return server_;
}
inline void Channel::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.server)
}

// optional uint32 id = 2;
inline bool Channel::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Channel::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Channel::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Channel::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Channel::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.id)
  return id_;
}
inline void Channel::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Channel.id)
}

// optional string name = 3;
inline bool Channel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Channel::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.name)
  return name_.GetNoArena();
}
inline void Channel::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Channel.name)
}
#if LANG_CXX11
inline void Channel::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Channel.name)
}
#endif
inline void Channel::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Channel.name)
}
inline void Channel::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Channel.name)
}
inline ::std::string* Channel::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.name)
}

// optional .MurmurRPC.Channel parent = 4;
inline bool Channel::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_parent() {
  if (parent_ != NULL) parent_->Clear();
  clear_has_parent();
}
inline const ::MurmurRPC::Channel& Channel::_internal_parent() const {
  return *parent_;
}
inline const ::MurmurRPC::Channel& Channel::parent() const {
  const ::MurmurRPC::Channel* p = parent_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.parent)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* Channel::release_parent() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.parent)
  clear_has_parent();
  ::MurmurRPC::Channel* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* Channel::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    parent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.parent)
  return parent_;
}
inline void Channel::set_allocated_parent(::MurmurRPC::Channel* parent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parent_;
  }
  if (parent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    set_has_parent();
  } else {
    clear_has_parent();
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.parent)
}

// repeated .MurmurRPC.Channel links = 5;
inline int Channel::links_size() const {
  return links_.size();
}
inline void Channel::clear_links() {
  links_.Clear();
}
inline ::MurmurRPC::Channel* Channel::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.links)
  return links_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >*
Channel::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Channel.links)
  return &links_;
}
inline const ::MurmurRPC::Channel& Channel::links(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.links)
  return links_.Get(index);
}
inline ::MurmurRPC::Channel* Channel::add_links() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Channel.links)
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Channel >&
Channel::links() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Channel.links)
  return links_;
}

// optional string description = 6;
inline bool Channel::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& Channel::description() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.description)
  return description_.GetNoArena();
}
inline void Channel::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Channel.description)
}
#if LANG_CXX11
inline void Channel::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Channel.description)
}
#endif
inline void Channel::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Channel.description)
}
inline void Channel::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Channel.description)
}
inline ::std::string* Channel::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Channel.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_description() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Channel.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Channel.description)
}

// optional bool temporary = 7;
inline bool Channel::has_temporary() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Channel::set_has_temporary() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Channel::clear_has_temporary() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Channel::clear_temporary() {
  temporary_ = false;
  clear_has_temporary();
}
inline bool Channel::temporary() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.temporary)
  return temporary_;
}
inline void Channel::set_temporary(bool value) {
  set_has_temporary();
  temporary_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Channel.temporary)
}

// optional int32 position = 8;
inline bool Channel::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Channel::set_has_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Channel::clear_has_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Channel::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 Channel::position() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Channel.position)
  return position_;
}
inline void Channel::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Channel.position)
}

// -------------------------------------------------------------------

// User_Query

// optional .MurmurRPC.Server server = 1;
inline bool User_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& User_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& User_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* User_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* User_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.Query.server)
  return server_;
}
inline void User_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.Query.server)
}

// -------------------------------------------------------------------

// User_List

// optional .MurmurRPC.Server server = 1;
inline bool User_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& User_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& User_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* User_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* User_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.List.server)
  return server_;
}
inline void User_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.List.server)
}

// repeated .MurmurRPC.User users = 2;
inline int User_List::users_size() const {
  return users_.size();
}
inline void User_List::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::User* User_List::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.List.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
User_List::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.User.List.users)
  return &users_;
}
inline const ::MurmurRPC::User& User_List::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.List.users)
  return users_.Get(index);
}
inline ::MurmurRPC::User* User_List::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.User.List.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
User_List::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.User.List.users)
  return users_;
}

// -------------------------------------------------------------------

// User_Kick

// optional .MurmurRPC.Server server = 1;
inline bool User_Kick::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User_Kick::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User_Kick::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User_Kick::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& User_Kick::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& User_Kick::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.Kick.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* User_Kick::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.Kick.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* User_Kick::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.Kick.server)
  return server_;
}
inline void User_Kick::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.Kick.server)
}

// optional .MurmurRPC.User user = 2;
inline bool User_Kick::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User_Kick::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User_Kick::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User_Kick::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& User_Kick::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& User_Kick::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.Kick.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* User_Kick::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.Kick.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* User_Kick::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.Kick.user)
  return user_;
}
inline void User_Kick::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.Kick.user)
}

// optional .MurmurRPC.User actor = 3;
inline bool User_Kick::has_actor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User_Kick::set_has_actor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User_Kick::clear_has_actor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User_Kick::clear_actor() {
  if (actor_ != NULL) actor_->Clear();
  clear_has_actor();
}
inline const ::MurmurRPC::User& User_Kick::_internal_actor() const {
  return *actor_;
}
inline const ::MurmurRPC::User& User_Kick::actor() const {
  const ::MurmurRPC::User* p = actor_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.Kick.actor)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* User_Kick::release_actor() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.Kick.actor)
  clear_has_actor();
  ::MurmurRPC::User* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* User_Kick::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    actor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.Kick.actor)
  return actor_;
}
inline void User_Kick::set_allocated_actor(::MurmurRPC::User* actor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_;
  }
  if (actor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor, submessage_arena);
    }
    set_has_actor();
  } else {
    clear_has_actor();
  }
  actor_ = actor;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.Kick.actor)
}

// optional string reason = 4;
inline bool User_Kick::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_Kick::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_Kick::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_Kick::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& User_Kick::reason() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.Kick.reason)
  return reason_.GetNoArena();
}
inline void User_Kick::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.Kick.reason)
}
#if LANG_CXX11
inline void User_Kick::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.Kick.reason)
}
#endif
inline void User_Kick::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.Kick.reason)
}
inline void User_Kick::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.Kick.reason)
}
inline ::std::string* User_Kick::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.Kick.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User_Kick::release_reason() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.Kick.reason)
  if (!has_reason()) {
    return NULL;
  }
  clear_has_reason();
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User_Kick::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.Kick.reason)
}

// -------------------------------------------------------------------

// User

// optional .MurmurRPC.Server server = 1;
inline bool User::has_server() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void User::set_has_server() {
  _has_bits_[0] |= 0x00000040u;
}
inline void User::clear_has_server() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void User::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& User::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& User::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* User::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* User::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.server)
  return server_;
}
inline void User::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.server)
}

// optional uint32 session = 2;
inline bool User::has_session() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void User::set_has_session() {
  _has_bits_[0] |= 0x00000200u;
}
inline void User::clear_has_session() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void User::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 User::session() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.session)
  return session_;
}
inline void User::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.session)
}

// optional uint32 id = 3;
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void User::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 User::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.id)
  return id_;
}
inline void User::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.id)
}

// optional string name = 4;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.name)
  return name_.GetNoArena();
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.name)
}
#if LANG_CXX11
inline void User::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.name)
}
#endif
inline void User::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.name)
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.name)
}

// optional bool mute = 5;
inline bool User::has_mute() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void User::set_has_mute() {
  _has_bits_[0] |= 0x00000800u;
}
inline void User::clear_has_mute() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void User::clear_mute() {
  mute_ = false;
  clear_has_mute();
}
inline bool User::mute() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.mute)
  return mute_;
}
inline void User::set_mute(bool value) {
  set_has_mute();
  mute_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.mute)
}

// optional bool deaf = 6;
inline bool User::has_deaf() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void User::set_has_deaf() {
  _has_bits_[0] |= 0x00001000u;
}
inline void User::clear_has_deaf() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void User::clear_deaf() {
  deaf_ = false;
  clear_has_deaf();
}
inline bool User::deaf() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.deaf)
  return deaf_;
}
inline void User::set_deaf(bool value) {
  set_has_deaf();
  deaf_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.deaf)
}

// optional bool suppress = 7;
inline bool User::has_suppress() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void User::set_has_suppress() {
  _has_bits_[0] |= 0x00002000u;
}
inline void User::clear_has_suppress() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void User::clear_suppress() {
  suppress_ = false;
  clear_has_suppress();
}
inline bool User::suppress() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.suppress)
  return suppress_;
}
inline void User::set_suppress(bool value) {
  set_has_suppress();
  suppress_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.suppress)
}

// optional bool priority_speaker = 8;
inline bool User::has_priority_speaker() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void User::set_has_priority_speaker() {
  _has_bits_[0] |= 0x00004000u;
}
inline void User::clear_has_priority_speaker() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void User::clear_priority_speaker() {
  priority_speaker_ = false;
  clear_has_priority_speaker();
}
inline bool User::priority_speaker() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.priority_speaker)
  return priority_speaker_;
}
inline void User::set_priority_speaker(bool value) {
  set_has_priority_speaker();
  priority_speaker_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.priority_speaker)
}

// optional bool self_mute = 9;
inline bool User::has_self_mute() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void User::set_has_self_mute() {
  _has_bits_[0] |= 0x00010000u;
}
inline void User::clear_has_self_mute() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void User::clear_self_mute() {
  self_mute_ = false;
  clear_has_self_mute();
}
inline bool User::self_mute() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.self_mute)
  return self_mute_;
}
inline void User::set_self_mute(bool value) {
  set_has_self_mute();
  self_mute_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.self_mute)
}

// optional bool self_deaf = 10;
inline bool User::has_self_deaf() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void User::set_has_self_deaf() {
  _has_bits_[0] |= 0x00020000u;
}
inline void User::clear_has_self_deaf() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void User::clear_self_deaf() {
  self_deaf_ = false;
  clear_has_self_deaf();
}
inline bool User::self_deaf() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.self_deaf)
  return self_deaf_;
}
inline void User::set_self_deaf(bool value) {
  set_has_self_deaf();
  self_deaf_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.self_deaf)
}

// optional bool recording = 11;
inline bool User::has_recording() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void User::set_has_recording() {
  _has_bits_[0] |= 0x00040000u;
}
inline void User::clear_has_recording() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void User::clear_recording() {
  recording_ = false;
  clear_has_recording();
}
inline bool User::recording() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.recording)
  return recording_;
}
inline void User::set_recording(bool value) {
  set_has_recording();
  recording_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.recording)
}

// optional .MurmurRPC.Channel channel = 12;
inline bool User::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void User::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void User::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void User::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& User::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& User::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* User::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* User::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.channel)
  return channel_;
}
inline void User::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.channel)
}

// optional uint32 online_secs = 13;
inline bool User::has_online_secs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void User::set_has_online_secs() {
  _has_bits_[0] |= 0x00008000u;
}
inline void User::clear_has_online_secs() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void User::clear_online_secs() {
  online_secs_ = 0u;
  clear_has_online_secs();
}
inline ::google::protobuf::uint32 User::online_secs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.online_secs)
  return online_secs_;
}
inline void User::set_online_secs(::google::protobuf::uint32 value) {
  set_has_online_secs();
  online_secs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.online_secs)
}

// optional uint32 idle_secs = 14;
inline bool User::has_idle_secs() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void User::set_has_idle_secs() {
  _has_bits_[0] |= 0x00100000u;
}
inline void User::clear_has_idle_secs() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void User::clear_idle_secs() {
  idle_secs_ = 0u;
  clear_has_idle_secs();
}
inline ::google::protobuf::uint32 User::idle_secs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.idle_secs)
  return idle_secs_;
}
inline void User::set_idle_secs(::google::protobuf::uint32 value) {
  set_has_idle_secs();
  idle_secs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.idle_secs)
}

// optional uint32 bytes_per_sec = 15;
inline bool User::has_bytes_per_sec() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void User::set_has_bytes_per_sec() {
  _has_bits_[0] |= 0x00200000u;
}
inline void User::clear_has_bytes_per_sec() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void User::clear_bytes_per_sec() {
  bytes_per_sec_ = 0u;
  clear_has_bytes_per_sec();
}
inline ::google::protobuf::uint32 User::bytes_per_sec() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.bytes_per_sec)
  return bytes_per_sec_;
}
inline void User::set_bytes_per_sec(::google::protobuf::uint32 value) {
  set_has_bytes_per_sec();
  bytes_per_sec_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.bytes_per_sec)
}

// optional .MurmurRPC.Version version = 16;
inline bool User::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void User::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void User::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void User::clear_version() {
  if (version_ != NULL) version_->Clear();
  clear_has_version();
}
inline const ::MurmurRPC::Version& User::_internal_version() const {
  return *version_;
}
inline const ::MurmurRPC::Version& User::version() const {
  const ::MurmurRPC::Version* p = version_;
  // @@protoc_insertion_point(field_get:MurmurRPC.User.version)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Version*>(
      &::MurmurRPC::_Version_default_instance_);
}
inline ::MurmurRPC::Version* User::release_version() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.version)
  clear_has_version();
  ::MurmurRPC::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline ::MurmurRPC::Version* User::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.version)
  return version_;
}
inline void User::set_allocated_version(::MurmurRPC::Version* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete version_;
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    set_has_version();
  } else {
    clear_has_version();
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.version)
}

// optional bytes plugin_context = 17;
inline bool User::has_plugin_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_plugin_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_plugin_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_plugin_context() {
  plugin_context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_plugin_context();
}
inline const ::std::string& User::plugin_context() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.plugin_context)
  return plugin_context_.GetNoArena();
}
inline void User::set_plugin_context(const ::std::string& value) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.plugin_context)
}
#if LANG_CXX11
inline void User::set_plugin_context(::std::string&& value) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.plugin_context)
}
#endif
inline void User::set_plugin_context(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.plugin_context)
}
inline void User::set_plugin_context(const void* value, size_t size) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.plugin_context)
}
inline ::std::string* User::mutable_plugin_context() {
  set_has_plugin_context();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.plugin_context)
  return plugin_context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_plugin_context() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.plugin_context)
  if (!has_plugin_context()) {
    return NULL;
  }
  clear_has_plugin_context();
  return plugin_context_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_plugin_context(::std::string* plugin_context) {
  if (plugin_context != NULL) {
    set_has_plugin_context();
  } else {
    clear_has_plugin_context();
  }
  plugin_context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_context);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.plugin_context)
}

// optional string plugin_identity = 18;
inline bool User::has_plugin_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_plugin_identity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_plugin_identity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_plugin_identity() {
  plugin_identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_plugin_identity();
}
inline const ::std::string& User::plugin_identity() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.plugin_identity)
  return plugin_identity_.GetNoArena();
}
inline void User::set_plugin_identity(const ::std::string& value) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.plugin_identity)
}
#if LANG_CXX11
inline void User::set_plugin_identity(::std::string&& value) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.plugin_identity)
}
#endif
inline void User::set_plugin_identity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.plugin_identity)
}
inline void User::set_plugin_identity(const char* value, size_t size) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.plugin_identity)
}
inline ::std::string* User::mutable_plugin_identity() {
  set_has_plugin_identity();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.plugin_identity)
  return plugin_identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_plugin_identity() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.plugin_identity)
  if (!has_plugin_identity()) {
    return NULL;
  }
  clear_has_plugin_identity();
  return plugin_identity_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_plugin_identity(::std::string* plugin_identity) {
  if (plugin_identity != NULL) {
    set_has_plugin_identity();
  } else {
    clear_has_plugin_identity();
  }
  plugin_identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_identity);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.plugin_identity)
}

// optional string comment = 19;
inline bool User::has_comment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_comment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_comment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& User::comment() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.comment)
  return comment_.GetNoArena();
}
inline void User::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.comment)
}
#if LANG_CXX11
inline void User::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.comment)
}
#endif
inline void User::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.comment)
}
inline void User::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.comment)
}
inline ::std::string* User::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_comment() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.comment)
  if (!has_comment()) {
    return NULL;
  }
  clear_has_comment();
  return comment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.comment)
}

// optional bytes texture = 20;
inline bool User::has_texture() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_texture() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_texture() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_texture() {
  texture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_texture();
}
inline const ::std::string& User::texture() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.texture)
  return texture_.GetNoArena();
}
inline void User::set_texture(const ::std::string& value) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.texture)
}
#if LANG_CXX11
inline void User::set_texture(::std::string&& value) {
  set_has_texture();
  texture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.texture)
}
#endif
inline void User::set_texture(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.texture)
}
inline void User::set_texture(const void* value, size_t size) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.texture)
}
inline ::std::string* User::mutable_texture() {
  set_has_texture();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.texture)
  return texture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_texture() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.texture)
  if (!has_texture()) {
    return NULL;
  }
  clear_has_texture();
  return texture_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_texture(::std::string* texture) {
  if (texture != NULL) {
    set_has_texture();
  } else {
    clear_has_texture();
  }
  texture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.texture)
}

// optional bytes address = 21;
inline bool User::has_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& User::address() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.address)
  return address_.GetNoArena();
}
inline void User::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.User.address)
}
#if LANG_CXX11
inline void User::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.User.address)
}
#endif
inline void User::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.User.address)
}
inline void User::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.User.address)
}
inline ::std::string* User::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.User.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_address() {
  // @@protoc_insertion_point(field_release:MurmurRPC.User.address)
  if (!has_address()) {
    return NULL;
  }
  clear_has_address();
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.User.address)
}

// optional bool tcp_only = 22;
inline bool User::has_tcp_only() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void User::set_has_tcp_only() {
  _has_bits_[0] |= 0x00080000u;
}
inline void User::clear_has_tcp_only() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void User::clear_tcp_only() {
  tcp_only_ = false;
  clear_has_tcp_only();
}
inline bool User::tcp_only() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.tcp_only)
  return tcp_only_;
}
inline void User::set_tcp_only(bool value) {
  set_has_tcp_only();
  tcp_only_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.tcp_only)
}

// optional float udp_ping_msecs = 23;
inline bool User::has_udp_ping_msecs() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void User::set_has_udp_ping_msecs() {
  _has_bits_[0] |= 0x00400000u;
}
inline void User::clear_has_udp_ping_msecs() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void User::clear_udp_ping_msecs() {
  udp_ping_msecs_ = 0;
  clear_has_udp_ping_msecs();
}
inline float User::udp_ping_msecs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.udp_ping_msecs)
  return udp_ping_msecs_;
}
inline void User::set_udp_ping_msecs(float value) {
  set_has_udp_ping_msecs();
  udp_ping_msecs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.udp_ping_msecs)
}

// optional float tcp_ping_msecs = 24;
inline bool User::has_tcp_ping_msecs() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void User::set_has_tcp_ping_msecs() {
  _has_bits_[0] |= 0x00800000u;
}
inline void User::clear_has_tcp_ping_msecs() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void User::clear_tcp_ping_msecs() {
  tcp_ping_msecs_ = 0;
  clear_has_tcp_ping_msecs();
}
inline float User::tcp_ping_msecs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.User.tcp_ping_msecs)
  return tcp_ping_msecs_;
}
inline void User::set_tcp_ping_msecs(float value) {
  set_has_tcp_ping_msecs();
  tcp_ping_msecs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.User.tcp_ping_msecs)
}

// -------------------------------------------------------------------

// Tree_Query

// optional .MurmurRPC.Server server = 1;
inline bool Tree_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tree_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tree_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tree_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Tree_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Tree_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Tree.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Tree_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Tree.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Tree_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Tree.Query.server)
  return server_;
}
inline void Tree_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Tree.Query.server)
}

// -------------------------------------------------------------------

// Tree

// optional .MurmurRPC.Server server = 1;
inline bool Tree::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tree::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tree::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tree::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Tree::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Tree::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Tree.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Tree::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Tree.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Tree::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Tree.server)
  return server_;
}
inline void Tree::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Tree.server)
}

// optional .MurmurRPC.Channel channel = 2;
inline bool Tree::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tree::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tree::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tree::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& Tree::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& Tree::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Tree.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* Tree::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Tree.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* Tree::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Tree.channel)
  return channel_;
}
inline void Tree::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Tree.channel)
}

// repeated .MurmurRPC.Tree children = 3;
inline int Tree::children_size() const {
  return children_.size();
}
inline void Tree::clear_children() {
  children_.Clear();
}
inline ::MurmurRPC::Tree* Tree::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Tree.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Tree >*
Tree::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Tree.children)
  return &children_;
}
inline const ::MurmurRPC::Tree& Tree::children(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Tree.children)
  return children_.Get(index);
}
inline ::MurmurRPC::Tree* Tree::add_children() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Tree.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Tree >&
Tree::children() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Tree.children)
  return children_;
}

// repeated .MurmurRPC.User users = 4;
inline int Tree::users_size() const {
  return users_.size();
}
inline void Tree::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::User* Tree::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Tree.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >*
Tree::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Tree.users)
  return &users_;
}
inline const ::MurmurRPC::User& Tree::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Tree.users)
  return users_.Get(index);
}
inline ::MurmurRPC::User* Tree::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Tree.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::User >&
Tree::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Tree.users)
  return users_;
}

// -------------------------------------------------------------------

// Ban_Query

// optional .MurmurRPC.Server server = 1;
inline bool Ban_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ban_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ban_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ban_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Ban_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Ban_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Ban_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Ban_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.Query.server)
  return server_;
}
inline void Ban_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.Query.server)
}

// -------------------------------------------------------------------

// Ban_List

// optional .MurmurRPC.Server server = 1;
inline bool Ban_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ban_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ban_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ban_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Ban_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Ban_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Ban_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Ban_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.List.server)
  return server_;
}
inline void Ban_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.List.server)
}

// repeated .MurmurRPC.Ban bans = 2;
inline int Ban_List::bans_size() const {
  return bans_.size();
}
inline void Ban_List::clear_bans() {
  bans_.Clear();
}
inline ::MurmurRPC::Ban* Ban_List::mutable_bans(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.List.bans)
  return bans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Ban >*
Ban_List::mutable_bans() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Ban.List.bans)
  return &bans_;
}
inline const ::MurmurRPC::Ban& Ban_List::bans(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.List.bans)
  return bans_.Get(index);
}
inline ::MurmurRPC::Ban* Ban_List::add_bans() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Ban.List.bans)
  return bans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::Ban >&
Ban_List::bans() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Ban.List.bans)
  return bans_;
}

// -------------------------------------------------------------------

// Ban

// optional .MurmurRPC.Server server = 1;
inline bool Ban::has_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ban::set_has_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ban::clear_has_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ban::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Ban::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Ban::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Ban::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Ban::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.server)
  return server_;
}
inline void Ban::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.server)
}

// optional bytes address = 2;
inline bool Ban::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ban::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ban::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ban::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Ban::address() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.address)
  return address_.GetNoArena();
}
inline void Ban::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.address)
}
#if LANG_CXX11
inline void Ban::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Ban.address)
}
#endif
inline void Ban::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Ban.address)
}
inline void Ban::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Ban.address)
}
inline ::std::string* Ban::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ban::release_address() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.address)
  if (!has_address()) {
    return NULL;
  }
  clear_has_address();
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ban::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.address)
}

// optional uint32 bits = 3;
inline bool Ban::has_bits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ban::set_has_bits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ban::clear_has_bits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ban::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Ban::bits() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.bits)
  return bits_;
}
inline void Ban::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.bits)
}

// optional string name = 4;
inline bool Ban::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ban::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ban::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ban::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Ban::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.name)
  return name_.GetNoArena();
}
inline void Ban::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.name)
}
#if LANG_CXX11
inline void Ban::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Ban.name)
}
#endif
inline void Ban::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Ban.name)
}
inline void Ban::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Ban.name)
}
inline ::std::string* Ban::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ban::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ban::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.name)
}

// optional string hash = 5;
inline bool Ban::has_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ban::set_has_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ban::clear_has_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ban::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Ban::hash() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.hash)
  return hash_.GetNoArena();
}
inline void Ban::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.hash)
}
#if LANG_CXX11
inline void Ban::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Ban.hash)
}
#endif
inline void Ban::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Ban.hash)
}
inline void Ban::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Ban.hash)
}
inline ::std::string* Ban::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ban::release_hash() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.hash)
  if (!has_hash()) {
    return NULL;
  }
  clear_has_hash();
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ban::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.hash)
}

// optional string reason = 6;
inline bool Ban::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ban::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ban::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ban::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& Ban::reason() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.reason)
  return reason_.GetNoArena();
}
inline void Ban::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.reason)
}
#if LANG_CXX11
inline void Ban::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Ban.reason)
}
#endif
inline void Ban::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Ban.reason)
}
inline void Ban::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Ban.reason)
}
inline ::std::string* Ban::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Ban.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ban::release_reason() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Ban.reason)
  if (!has_reason()) {
    return NULL;
  }
  clear_has_reason();
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ban::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Ban.reason)
}

// optional int64 start = 7;
inline bool Ban::has_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ban::set_has_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ban::clear_has_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ban::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 Ban::start() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.start)
  return start_;
}
inline void Ban::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.start)
}

// optional int64 duration_secs = 8;
inline bool Ban::has_duration_secs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ban::set_has_duration_secs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ban::clear_has_duration_secs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ban::clear_duration_secs() {
  duration_secs_ = GOOGLE_LONGLONG(0);
  clear_has_duration_secs();
}
inline ::google::protobuf::int64 Ban::duration_secs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Ban.duration_secs)
  return duration_secs_;
}
inline void Ban::set_duration_secs(::google::protobuf::int64 value) {
  set_has_duration_secs();
  duration_secs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Ban.duration_secs)
}

// -------------------------------------------------------------------

// ACL_Group

// optional string name = 1;
inline bool ACL_Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ACL_Group::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.name)
  return name_.GetNoArena();
}
inline void ACL_Group::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.Group.name)
}
#if LANG_CXX11
inline void ACL_Group::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.ACL.Group.name)
}
#endif
inline void ACL_Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.ACL.Group.name)
}
inline void ACL_Group::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.ACL.Group.name)
}
inline ::std::string* ACL_Group::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_Group::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.Group.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.Group.name)
}

// optional bool inherited = 2;
inline bool ACL_Group::has_inherited() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_Group::set_has_inherited() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_Group::clear_has_inherited() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_Group::clear_inherited() {
  inherited_ = false;
  clear_has_inherited();
}
inline bool ACL_Group::inherited() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.inherited)
  return inherited_;
}
inline void ACL_Group::set_inherited(bool value) {
  set_has_inherited();
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.Group.inherited)
}

// optional bool inherit = 3;
inline bool ACL_Group::has_inherit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_Group::set_has_inherit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_Group::clear_has_inherit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_Group::clear_inherit() {
  inherit_ = false;
  clear_has_inherit();
}
inline bool ACL_Group::inherit() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.inherit)
  return inherit_;
}
inline void ACL_Group::set_inherit(bool value) {
  set_has_inherit();
  inherit_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.Group.inherit)
}

// optional bool inheritable = 4;
inline bool ACL_Group::has_inheritable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_Group::set_has_inheritable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_Group::clear_has_inheritable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_Group::clear_inheritable() {
  inheritable_ = false;
  clear_has_inheritable();
}
inline bool ACL_Group::inheritable() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.inheritable)
  return inheritable_;
}
inline void ACL_Group::set_inheritable(bool value) {
  set_has_inheritable();
  inheritable_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.Group.inheritable)
}

// repeated .MurmurRPC.DatabaseUser users_add = 5;
inline int ACL_Group::users_add_size() const {
  return users_add_.size();
}
inline void ACL_Group::clear_users_add() {
  users_add_.Clear();
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::mutable_users_add(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Group.users_add)
  return users_add_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
ACL_Group::mutable_users_add() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.ACL.Group.users_add)
  return &users_add_;
}
inline const ::MurmurRPC::DatabaseUser& ACL_Group::users_add(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.users_add)
  return users_add_.Get(index);
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::add_users_add() {
  // @@protoc_insertion_point(field_add:MurmurRPC.ACL.Group.users_add)
  return users_add_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
ACL_Group::users_add() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.ACL.Group.users_add)
  return users_add_;
}

// repeated .MurmurRPC.DatabaseUser users_remove = 6;
inline int ACL_Group::users_remove_size() const {
  return users_remove_.size();
}
inline void ACL_Group::clear_users_remove() {
  users_remove_.Clear();
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::mutable_users_remove(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Group.users_remove)
  return users_remove_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
ACL_Group::mutable_users_remove() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.ACL.Group.users_remove)
  return &users_remove_;
}
inline const ::MurmurRPC::DatabaseUser& ACL_Group::users_remove(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.users_remove)
  return users_remove_.Get(index);
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::add_users_remove() {
  // @@protoc_insertion_point(field_add:MurmurRPC.ACL.Group.users_remove)
  return users_remove_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
ACL_Group::users_remove() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.ACL.Group.users_remove)
  return users_remove_;
}

// repeated .MurmurRPC.DatabaseUser users = 7;
inline int ACL_Group::users_size() const {
  return users_.size();
}
inline void ACL_Group::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Group.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
ACL_Group::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.ACL.Group.users)
  return &users_;
}
inline const ::MurmurRPC::DatabaseUser& ACL_Group::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Group.users)
  return users_.Get(index);
}
inline ::MurmurRPC::DatabaseUser* ACL_Group::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.ACL.Group.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
ACL_Group::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.ACL.Group.users)
  return users_;
}

// -------------------------------------------------------------------

// ACL_Query

// optional .MurmurRPC.Server server = 1;
inline bool ACL_Query::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Query::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& ACL_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& ACL_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* ACL_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* ACL_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Query.server)
  return server_;
}
inline void ACL_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.Query.server)
}

// optional .MurmurRPC.User user = 2;
inline bool ACL_Query::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_Query::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_Query::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_Query::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& ACL_Query::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& ACL_Query::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Query.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* ACL_Query::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.Query.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* ACL_Query::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Query.user)
  return user_;
}
inline void ACL_Query::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.Query.user)
}

// optional .MurmurRPC.Channel channel = 3;
inline bool ACL_Query::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_Query::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_Query::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_Query::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& ACL_Query::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& ACL_Query::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.Query.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* ACL_Query::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.Query.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* ACL_Query::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.Query.channel)
  return channel_;
}
inline void ACL_Query::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.Query.channel)
}

// -------------------------------------------------------------------

// ACL_List

// optional .MurmurRPC.Server server = 1;
inline bool ACL_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& ACL_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& ACL_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* ACL_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* ACL_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.List.server)
  return server_;
}
inline void ACL_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.List.server)
}

// optional .MurmurRPC.Channel channel = 2;
inline bool ACL_List::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_List::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_List::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_List::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& ACL_List::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& ACL_List::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.List.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* ACL_List::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.List.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* ACL_List::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.List.channel)
  return channel_;
}
inline void ACL_List::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.List.channel)
}

// repeated .MurmurRPC.ACL acls = 3;
inline int ACL_List::acls_size() const {
  return acls_.size();
}
inline void ACL_List::clear_acls() {
  acls_.Clear();
}
inline ::MurmurRPC::ACL* ACL_List::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.List.acls)
  return acls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL >*
ACL_List::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.ACL.List.acls)
  return &acls_;
}
inline const ::MurmurRPC::ACL& ACL_List::acls(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.List.acls)
  return acls_.Get(index);
}
inline ::MurmurRPC::ACL* ACL_List::add_acls() {
  // @@protoc_insertion_point(field_add:MurmurRPC.ACL.List.acls)
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL >&
ACL_List::acls() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.ACL.List.acls)
  return acls_;
}

// repeated .MurmurRPC.ACL.Group groups = 4;
inline int ACL_List::groups_size() const {
  return groups_.size();
}
inline void ACL_List::clear_groups() {
  groups_.Clear();
}
inline ::MurmurRPC::ACL_Group* ACL_List::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.List.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >*
ACL_List::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.ACL.List.groups)
  return &groups_;
}
inline const ::MurmurRPC::ACL_Group& ACL_List::groups(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.List.groups)
  return groups_.Get(index);
}
inline ::MurmurRPC::ACL_Group* ACL_List::add_groups() {
  // @@protoc_insertion_point(field_add:MurmurRPC.ACL.List.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >&
ACL_List::groups() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.ACL.List.groups)
  return groups_;
}

// optional bool inherit = 5;
inline bool ACL_List::has_inherit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_List::set_has_inherit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_List::clear_has_inherit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_List::clear_inherit() {
  inherit_ = false;
  clear_has_inherit();
}
inline bool ACL_List::inherit() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.List.inherit)
  return inherit_;
}
inline void ACL_List::set_inherit(bool value) {
  set_has_inherit();
  inherit_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.List.inherit)
}

// -------------------------------------------------------------------

// ACL_TemporaryGroup

// optional .MurmurRPC.Server server = 1;
inline bool ACL_TemporaryGroup::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_TemporaryGroup::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_TemporaryGroup::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_TemporaryGroup::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& ACL_TemporaryGroup::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& ACL_TemporaryGroup::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.TemporaryGroup.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* ACL_TemporaryGroup::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.TemporaryGroup.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* ACL_TemporaryGroup::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.TemporaryGroup.server)
  return server_;
}
inline void ACL_TemporaryGroup::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.TemporaryGroup.server)
}

// optional .MurmurRPC.Channel channel = 2;
inline bool ACL_TemporaryGroup::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_TemporaryGroup::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_TemporaryGroup::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_TemporaryGroup::clear_channel() {
  if (channel_ != NULL) channel_->Clear();
  clear_has_channel();
}
inline const ::MurmurRPC::Channel& ACL_TemporaryGroup::_internal_channel() const {
  return *channel_;
}
inline const ::MurmurRPC::Channel& ACL_TemporaryGroup::channel() const {
  const ::MurmurRPC::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.TemporaryGroup.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Channel*>(
      &::MurmurRPC::_Channel_default_instance_);
}
inline ::MurmurRPC::Channel* ACL_TemporaryGroup::release_channel() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.TemporaryGroup.channel)
  clear_has_channel();
  ::MurmurRPC::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::MurmurRPC::Channel* ACL_TemporaryGroup::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.TemporaryGroup.channel)
  return channel_;
}
inline void ACL_TemporaryGroup::set_allocated_channel(::MurmurRPC::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.TemporaryGroup.channel)
}

// optional .MurmurRPC.User user = 3;
inline bool ACL_TemporaryGroup::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_TemporaryGroup::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_TemporaryGroup::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_TemporaryGroup::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& ACL_TemporaryGroup::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& ACL_TemporaryGroup::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.TemporaryGroup.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* ACL_TemporaryGroup::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.TemporaryGroup.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* ACL_TemporaryGroup::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.TemporaryGroup.user)
  return user_;
}
inline void ACL_TemporaryGroup::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.TemporaryGroup.user)
}

// optional string name = 4;
inline bool ACL_TemporaryGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_TemporaryGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_TemporaryGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_TemporaryGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ACL_TemporaryGroup::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.TemporaryGroup.name)
  return name_.GetNoArena();
}
inline void ACL_TemporaryGroup::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.TemporaryGroup.name)
}
#if LANG_CXX11
inline void ACL_TemporaryGroup::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.ACL.TemporaryGroup.name)
}
#endif
inline void ACL_TemporaryGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.ACL.TemporaryGroup.name)
}
inline void ACL_TemporaryGroup::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.ACL.TemporaryGroup.name)
}
inline ::std::string* ACL_TemporaryGroup::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.TemporaryGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_TemporaryGroup::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.TemporaryGroup.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_TemporaryGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.TemporaryGroup.name)
}

// -------------------------------------------------------------------

// ACL

// optional bool apply_here = 3;
inline bool ACL::has_apply_here() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL::set_has_apply_here() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL::clear_has_apply_here() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL::clear_apply_here() {
  apply_here_ = false;
  clear_has_apply_here();
}
inline bool ACL::apply_here() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.apply_here)
  return apply_here_;
}
inline void ACL::set_apply_here(bool value) {
  set_has_apply_here();
  apply_here_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.apply_here)
}

// optional bool apply_subs = 4;
inline bool ACL::has_apply_subs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL::set_has_apply_subs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL::clear_has_apply_subs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL::clear_apply_subs() {
  apply_subs_ = false;
  clear_has_apply_subs();
}
inline bool ACL::apply_subs() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.apply_subs)
  return apply_subs_;
}
inline void ACL::set_apply_subs(bool value) {
  set_has_apply_subs();
  apply_subs_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.apply_subs)
}

// optional bool inherited = 5;
inline bool ACL::has_inherited() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACL::set_has_inherited() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACL::clear_has_inherited() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACL::clear_inherited() {
  inherited_ = false;
  clear_has_inherited();
}
inline bool ACL::inherited() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.inherited)
  return inherited_;
}
inline void ACL::set_inherited(bool value) {
  set_has_inherited();
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.inherited)
}

// optional .MurmurRPC.DatabaseUser user = 6;
inline bool ACL::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& ACL::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& ACL::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* ACL::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* ACL::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.user)
  return user_;
}
inline void ACL::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.user)
}

// optional .MurmurRPC.ACL.Group group = 7;
inline bool ACL::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL::clear_group() {
  if (group_ != NULL) group_->Clear();
  clear_has_group();
}
inline const ::MurmurRPC::ACL_Group& ACL::_internal_group() const {
  return *group_;
}
inline const ::MurmurRPC::ACL_Group& ACL::group() const {
  const ::MurmurRPC::ACL_Group* p = group_;
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.group)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::ACL_Group*>(
      &::MurmurRPC::_ACL_Group_default_instance_);
}
inline ::MurmurRPC::ACL_Group* ACL::release_group() {
  // @@protoc_insertion_point(field_release:MurmurRPC.ACL.group)
  clear_has_group();
  ::MurmurRPC::ACL_Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline ::MurmurRPC::ACL_Group* ACL::mutable_group() {
  set_has_group();
  if (group_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::ACL_Group>(GetArenaNoVirtual());
    group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.ACL.group)
  return group_;
}
inline void ACL::set_allocated_group(::MurmurRPC::ACL_Group* group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete group_;
  }
  if (group) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    set_has_group();
  } else {
    clear_has_group();
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.ACL.group)
}

// optional uint32 allow = 8;
inline bool ACL::has_allow() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACL::set_has_allow() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACL::clear_has_allow() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACL::clear_allow() {
  allow_ = 0u;
  clear_has_allow();
}
inline ::google::protobuf::uint32 ACL::allow() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.allow)
  return allow_;
}
inline void ACL::set_allow(::google::protobuf::uint32 value) {
  set_has_allow();
  allow_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.allow)
}

// optional uint32 deny = 9;
inline bool ACL::has_deny() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACL::set_has_deny() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACL::clear_has_deny() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACL::clear_deny() {
  deny_ = 0u;
  clear_has_deny();
}
inline ::google::protobuf::uint32 ACL::deny() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.ACL.deny)
  return deny_;
}
inline void ACL::set_deny(::google::protobuf::uint32 value) {
  set_has_deny();
  deny_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.ACL.deny)
}

// -------------------------------------------------------------------

// Authenticator_Request_Authenticate

// optional string name = 1;
inline bool Authenticator_Request_Authenticate::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Authenticate::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Authenticate::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Authenticate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Authenticator_Request_Authenticate::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Authenticate.name)
  return name_.GetNoArena();
}
inline void Authenticator_Request_Authenticate::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.name)
}
#if LANG_CXX11
inline void Authenticator_Request_Authenticate::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Request.Authenticate.name)
}
#endif
inline void Authenticator_Request_Authenticate::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Authenticate.name)
}
inline void Authenticator_Request_Authenticate::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Authenticate.name)
}
inline ::std::string* Authenticator_Request_Authenticate::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Authenticate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Request_Authenticate::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Authenticate.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Request_Authenticate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Authenticate.name)
}

// optional string password = 2;
inline bool Authenticator_Request_Authenticate::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Request_Authenticate::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Request_Authenticate::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Request_Authenticate::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Authenticator_Request_Authenticate::password() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Authenticate.password)
  return password_.GetNoArena();
}
inline void Authenticator_Request_Authenticate::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.password)
}
#if LANG_CXX11
inline void Authenticator_Request_Authenticate::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Request.Authenticate.password)
}
#endif
inline void Authenticator_Request_Authenticate::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Authenticate.password)
}
inline void Authenticator_Request_Authenticate::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Authenticate.password)
}
inline ::std::string* Authenticator_Request_Authenticate::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Authenticate.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Request_Authenticate::release_password() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Authenticate.password)
  if (!has_password()) {
    return NULL;
  }
  clear_has_password();
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Request_Authenticate::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Authenticate.password)
}

// repeated bytes certificates = 3;
inline int Authenticator_Request_Authenticate::certificates_size() const {
  return certificates_.size();
}
inline void Authenticator_Request_Authenticate::clear_certificates() {
  certificates_.Clear();
}
inline const ::std::string& Authenticator_Request_Authenticate::certificates(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  return certificates_.Get(index);
}
inline ::std::string* Authenticator_Request_Authenticate::mutable_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  return certificates_.Mutable(index);
}
inline void Authenticator_Request_Authenticate::set_certificates(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  certificates_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Authenticator_Request_Authenticate::set_certificates(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  certificates_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Authenticator_Request_Authenticate::set_certificates(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
inline void Authenticator_Request_Authenticate::set_certificates(int index, const void* value, size_t size) {
  certificates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
inline ::std::string* Authenticator_Request_Authenticate::add_certificates() {
  // @@protoc_insertion_point(field_add_mutable:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  return certificates_.Add();
}
inline void Authenticator_Request_Authenticate::add_certificates(const ::std::string& value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
#if LANG_CXX11
inline void Authenticator_Request_Authenticate::add_certificates(::std::string&& value) {
  certificates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
#endif
inline void Authenticator_Request_Authenticate::add_certificates(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
inline void Authenticator_Request_Authenticate::add_certificates(const void* value, size_t size) {
  certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MurmurRPC.Authenticator.Request.Authenticate.certificates)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Authenticator_Request_Authenticate::certificates() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  return certificates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Authenticator_Request_Authenticate::mutable_certificates() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Authenticator.Request.Authenticate.certificates)
  return &certificates_;
}

// optional string certificate_hash = 4;
inline bool Authenticator_Request_Authenticate::has_certificate_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Authenticator_Request_Authenticate::set_has_certificate_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Authenticator_Request_Authenticate::clear_has_certificate_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Authenticator_Request_Authenticate::clear_certificate_hash() {
  certificate_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_certificate_hash();
}
inline const ::std::string& Authenticator_Request_Authenticate::certificate_hash() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
  return certificate_hash_.GetNoArena();
}
inline void Authenticator_Request_Authenticate::set_certificate_hash(const ::std::string& value) {
  set_has_certificate_hash();
  certificate_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
}
#if LANG_CXX11
inline void Authenticator_Request_Authenticate::set_certificate_hash(::std::string&& value) {
  set_has_certificate_hash();
  certificate_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
}
#endif
inline void Authenticator_Request_Authenticate::set_certificate_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_certificate_hash();
  certificate_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
}
inline void Authenticator_Request_Authenticate::set_certificate_hash(const char* value, size_t size) {
  set_has_certificate_hash();
  certificate_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
}
inline ::std::string* Authenticator_Request_Authenticate::mutable_certificate_hash() {
  set_has_certificate_hash();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
  return certificate_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Request_Authenticate::release_certificate_hash() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
  if (!has_certificate_hash()) {
    return NULL;
  }
  clear_has_certificate_hash();
  return certificate_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Request_Authenticate::set_allocated_certificate_hash(::std::string* certificate_hash) {
  if (certificate_hash != NULL) {
    set_has_certificate_hash();
  } else {
    clear_has_certificate_hash();
  }
  certificate_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), certificate_hash);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Authenticate.certificate_hash)
}

// optional bool strong_certificate = 5;
inline bool Authenticator_Request_Authenticate::has_strong_certificate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Authenticator_Request_Authenticate::set_has_strong_certificate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Authenticator_Request_Authenticate::clear_has_strong_certificate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Authenticator_Request_Authenticate::clear_strong_certificate() {
  strong_certificate_ = false;
  clear_has_strong_certificate();
}
inline bool Authenticator_Request_Authenticate::strong_certificate() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Authenticate.strong_certificate)
  return strong_certificate_;
}
inline void Authenticator_Request_Authenticate::set_strong_certificate(bool value) {
  set_has_strong_certificate();
  strong_certificate_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Authenticate.strong_certificate)
}

// -------------------------------------------------------------------

// Authenticator_Request_Find

// optional uint32 id = 1;
inline bool Authenticator_Request_Find::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Request_Find::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Request_Find::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Request_Find::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Authenticator_Request_Find::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Find.id)
  return id_;
}
inline void Authenticator_Request_Find::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Find.id)
}

// optional string name = 2;
inline bool Authenticator_Request_Find::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Find::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Find::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Find::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Authenticator_Request_Find::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Find.name)
  return name_.GetNoArena();
}
inline void Authenticator_Request_Find::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Find.name)
}
#if LANG_CXX11
inline void Authenticator_Request_Find::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Request.Find.name)
}
#endif
inline void Authenticator_Request_Find::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Find.name)
}
inline void Authenticator_Request_Find::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Find.name)
}
inline ::std::string* Authenticator_Request_Find::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Find.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Request_Find::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Find.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Request_Find::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Find.name)
}

// -------------------------------------------------------------------

// Authenticator_Request_Query

// optional string filter = 1;
inline bool Authenticator_Request_Query::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Query::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Query::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Query::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filter();
}
inline const ::std::string& Authenticator_Request_Query::filter() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Query.filter)
  return filter_.GetNoArena();
}
inline void Authenticator_Request_Query::set_filter(const ::std::string& value) {
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Request.Query.filter)
}
#if LANG_CXX11
inline void Authenticator_Request_Query::set_filter(::std::string&& value) {
  set_has_filter();
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Request.Query.filter)
}
#endif
inline void Authenticator_Request_Query::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Request.Query.filter)
}
inline void Authenticator_Request_Query::set_filter(const char* value, size_t size) {
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Request.Query.filter)
}
inline ::std::string* Authenticator_Request_Query::mutable_filter() {
  set_has_filter();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Query.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Request_Query::release_filter() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Query.filter)
  if (!has_filter()) {
    return NULL;
  }
  clear_has_filter();
  return filter_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Request_Query::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Query.filter)
}

// -------------------------------------------------------------------

// Authenticator_Request_Register

// optional .MurmurRPC.DatabaseUser user = 1;
inline bool Authenticator_Request_Register::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Register::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Register::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Register::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Register::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Register::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Register.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Register::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Register.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Register::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Register.user)
  return user_;
}
inline void Authenticator_Request_Register::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Register.user)
}

// -------------------------------------------------------------------

// Authenticator_Request_Deregister

// optional .MurmurRPC.DatabaseUser user = 1;
inline bool Authenticator_Request_Deregister::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Deregister::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Deregister::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Deregister::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Deregister::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Deregister::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Deregister.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Deregister::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Deregister.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Deregister::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Deregister.user)
  return user_;
}
inline void Authenticator_Request_Deregister::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Deregister.user)
}

// -------------------------------------------------------------------

// Authenticator_Request_Update

// optional .MurmurRPC.DatabaseUser user = 1;
inline bool Authenticator_Request_Update::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request_Update::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request_Update::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request_Update::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Update::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Request_Update::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.Update.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Update::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.Update.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Request_Update::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.Update.user)
  return user_;
}
inline void Authenticator_Request_Update::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.Update.user)
}

// -------------------------------------------------------------------

// Authenticator_Request

// optional .MurmurRPC.Authenticator.Request.Authenticate authenticate = 1;
inline bool Authenticator_Request::has_authenticate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Request::set_has_authenticate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Request::clear_has_authenticate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Request::clear_authenticate() {
  if (authenticate_ != NULL) authenticate_->Clear();
  clear_has_authenticate();
}
inline const ::MurmurRPC::Authenticator_Request_Authenticate& Authenticator_Request::_internal_authenticate() const {
  return *authenticate_;
}
inline const ::MurmurRPC::Authenticator_Request_Authenticate& Authenticator_Request::authenticate() const {
  const ::MurmurRPC::Authenticator_Request_Authenticate* p = authenticate_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.authenticate)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Authenticate*>(
      &::MurmurRPC::_Authenticator_Request_Authenticate_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Authenticate* Authenticator_Request::release_authenticate() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.authenticate)
  clear_has_authenticate();
  ::MurmurRPC::Authenticator_Request_Authenticate* temp = authenticate_;
  authenticate_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Authenticate* Authenticator_Request::mutable_authenticate() {
  set_has_authenticate();
  if (authenticate_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Authenticate>(GetArenaNoVirtual());
    authenticate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.authenticate)
  return authenticate_;
}
inline void Authenticator_Request::set_allocated_authenticate(::MurmurRPC::Authenticator_Request_Authenticate* authenticate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authenticate_;
  }
  if (authenticate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authenticate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authenticate, submessage_arena);
    }
    set_has_authenticate();
  } else {
    clear_has_authenticate();
  }
  authenticate_ = authenticate;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.authenticate)
}

// optional .MurmurRPC.Authenticator.Request.Find find = 2;
inline bool Authenticator_Request::has_find() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Request::set_has_find() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Request::clear_has_find() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Request::clear_find() {
  if (find_ != NULL) find_->Clear();
  clear_has_find();
}
inline const ::MurmurRPC::Authenticator_Request_Find& Authenticator_Request::_internal_find() const {
  return *find_;
}
inline const ::MurmurRPC::Authenticator_Request_Find& Authenticator_Request::find() const {
  const ::MurmurRPC::Authenticator_Request_Find* p = find_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.find)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Find*>(
      &::MurmurRPC::_Authenticator_Request_Find_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Find* Authenticator_Request::release_find() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.find)
  clear_has_find();
  ::MurmurRPC::Authenticator_Request_Find* temp = find_;
  find_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Find* Authenticator_Request::mutable_find() {
  set_has_find();
  if (find_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Find>(GetArenaNoVirtual());
    find_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.find)
  return find_;
}
inline void Authenticator_Request::set_allocated_find(::MurmurRPC::Authenticator_Request_Find* find) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete find_;
  }
  if (find) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      find = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, find, submessage_arena);
    }
    set_has_find();
  } else {
    clear_has_find();
  }
  find_ = find;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.find)
}

// optional .MurmurRPC.Authenticator.Request.Query query = 3;
inline bool Authenticator_Request::has_query() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Authenticator_Request::set_has_query() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Authenticator_Request::clear_has_query() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Authenticator_Request::clear_query() {
  if (query_ != NULL) query_->Clear();
  clear_has_query();
}
inline const ::MurmurRPC::Authenticator_Request_Query& Authenticator_Request::_internal_query() const {
  return *query_;
}
inline const ::MurmurRPC::Authenticator_Request_Query& Authenticator_Request::query() const {
  const ::MurmurRPC::Authenticator_Request_Query* p = query_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.query)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Query*>(
      &::MurmurRPC::_Authenticator_Request_Query_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Query* Authenticator_Request::release_query() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.query)
  clear_has_query();
  ::MurmurRPC::Authenticator_Request_Query* temp = query_;
  query_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Query* Authenticator_Request::mutable_query() {
  set_has_query();
  if (query_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Query>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.query)
  return query_;
}
inline void Authenticator_Request::set_allocated_query(::MurmurRPC::Authenticator_Request_Query* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete query_;
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    set_has_query();
  } else {
    clear_has_query();
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.query)
}

// optional .MurmurRPC.Authenticator.Request.Register register = 4;
inline bool Authenticator_Request::has_register_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Authenticator_Request::set_has_register_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Authenticator_Request::clear_has_register_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Authenticator_Request::clear_register_() {
  if (register__ != NULL) register__->Clear();
  clear_has_register_();
}
inline const ::MurmurRPC::Authenticator_Request_Register& Authenticator_Request::_internal_register_() const {
  return *register__;
}
inline const ::MurmurRPC::Authenticator_Request_Register& Authenticator_Request::register_() const {
  const ::MurmurRPC::Authenticator_Request_Register* p = register__;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.register)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Register*>(
      &::MurmurRPC::_Authenticator_Request_Register_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Register* Authenticator_Request::release_register_() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.register)
  clear_has_register_();
  ::MurmurRPC::Authenticator_Request_Register* temp = register__;
  register__ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Register* Authenticator_Request::mutable_register_() {
  set_has_register_();
  if (register__ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Register>(GetArenaNoVirtual());
    register__ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.register)
  return register__;
}
inline void Authenticator_Request::set_allocated_register_(::MurmurRPC::Authenticator_Request_Register* register_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete register__;
  }
  if (register_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      register_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, register_, submessage_arena);
    }
    set_has_register_();
  } else {
    clear_has_register_();
  }
  register__ = register_;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.register)
}

// optional .MurmurRPC.Authenticator.Request.Deregister deregister = 5;
inline bool Authenticator_Request::has_deregister() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Authenticator_Request::set_has_deregister() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Authenticator_Request::clear_has_deregister() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Authenticator_Request::clear_deregister() {
  if (deregister_ != NULL) deregister_->Clear();
  clear_has_deregister();
}
inline const ::MurmurRPC::Authenticator_Request_Deregister& Authenticator_Request::_internal_deregister() const {
  return *deregister_;
}
inline const ::MurmurRPC::Authenticator_Request_Deregister& Authenticator_Request::deregister() const {
  const ::MurmurRPC::Authenticator_Request_Deregister* p = deregister_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.deregister)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Deregister*>(
      &::MurmurRPC::_Authenticator_Request_Deregister_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Deregister* Authenticator_Request::release_deregister() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.deregister)
  clear_has_deregister();
  ::MurmurRPC::Authenticator_Request_Deregister* temp = deregister_;
  deregister_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Deregister* Authenticator_Request::mutable_deregister() {
  set_has_deregister();
  if (deregister_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Deregister>(GetArenaNoVirtual());
    deregister_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.deregister)
  return deregister_;
}
inline void Authenticator_Request::set_allocated_deregister(::MurmurRPC::Authenticator_Request_Deregister* deregister) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete deregister_;
  }
  if (deregister) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deregister = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deregister, submessage_arena);
    }
    set_has_deregister();
  } else {
    clear_has_deregister();
  }
  deregister_ = deregister;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.deregister)
}

// optional .MurmurRPC.Authenticator.Request.Update update = 6;
inline bool Authenticator_Request::has_update() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Authenticator_Request::set_has_update() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Authenticator_Request::clear_has_update() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Authenticator_Request::clear_update() {
  if (update_ != NULL) update_->Clear();
  clear_has_update();
}
inline const ::MurmurRPC::Authenticator_Request_Update& Authenticator_Request::_internal_update() const {
  return *update_;
}
inline const ::MurmurRPC::Authenticator_Request_Update& Authenticator_Request::update() const {
  const ::MurmurRPC::Authenticator_Request_Update* p = update_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Request.update)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Request_Update*>(
      &::MurmurRPC::_Authenticator_Request_Update_default_instance_);
}
inline ::MurmurRPC::Authenticator_Request_Update* Authenticator_Request::release_update() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Request.update)
  clear_has_update();
  ::MurmurRPC::Authenticator_Request_Update* temp = update_;
  update_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Request_Update* Authenticator_Request::mutable_update() {
  set_has_update();
  if (update_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Request_Update>(GetArenaNoVirtual());
    update_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Request.update)
  return update_;
}
inline void Authenticator_Request::set_allocated_update(::MurmurRPC::Authenticator_Request_Update* update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_;
  }
  if (update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update, submessage_arena);
    }
    set_has_update();
  } else {
    clear_has_update();
  }
  update_ = update;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Request.update)
}

// -------------------------------------------------------------------

// Authenticator_Response_Initialize

// optional .MurmurRPC.Server server = 1;
inline bool Authenticator_Response_Initialize::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Initialize::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Initialize::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Initialize::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& Authenticator_Response_Initialize::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& Authenticator_Response_Initialize::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Initialize.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* Authenticator_Response_Initialize::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.Initialize.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* Authenticator_Response_Initialize::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Initialize.server)
  return server_;
}
inline void Authenticator_Response_Initialize::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.Initialize.server)
}

// -------------------------------------------------------------------

// Authenticator_Response_Authenticate

// optional .MurmurRPC.Authenticator.Response.Status status = 1;
inline bool Authenticator_Response_Authenticate::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Response_Authenticate::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Response_Authenticate::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Response_Authenticate::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::MurmurRPC::Authenticator_Response_Status Authenticator_Response_Authenticate::status() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Authenticate.status)
  return static_cast< ::MurmurRPC::Authenticator_Response_Status >(status_);
}
inline void Authenticator_Response_Authenticate::set_status(::MurmurRPC::Authenticator_Response_Status value) {
  assert(::MurmurRPC::Authenticator_Response_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Authenticate.status)
}

// optional uint32 id = 2;
inline bool Authenticator_Response_Authenticate::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Authenticator_Response_Authenticate::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Authenticator_Response_Authenticate::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Authenticator_Response_Authenticate::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Authenticator_Response_Authenticate::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Authenticate.id)
  return id_;
}
inline void Authenticator_Response_Authenticate::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Authenticate.id)
}

// optional string name = 3;
inline bool Authenticator_Response_Authenticate::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Authenticate::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Authenticate::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Authenticate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Authenticator_Response_Authenticate::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Authenticate.name)
  return name_.GetNoArena();
}
inline void Authenticator_Response_Authenticate::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Authenticate.name)
}
#if LANG_CXX11
inline void Authenticator_Response_Authenticate::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.Authenticator.Response.Authenticate.name)
}
#endif
inline void Authenticator_Response_Authenticate::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.Authenticator.Response.Authenticate.name)
}
inline void Authenticator_Response_Authenticate::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.Authenticator.Response.Authenticate.name)
}
inline ::std::string* Authenticator_Response_Authenticate::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Authenticate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticator_Response_Authenticate::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.Authenticate.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticator_Response_Authenticate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.Authenticate.name)
}

// repeated .MurmurRPC.ACL.Group groups = 4;
inline int Authenticator_Response_Authenticate::groups_size() const {
  return groups_.size();
}
inline void Authenticator_Response_Authenticate::clear_groups() {
  groups_.Clear();
}
inline ::MurmurRPC::ACL_Group* Authenticator_Response_Authenticate::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Authenticate.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >*
Authenticator_Response_Authenticate::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Authenticator.Response.Authenticate.groups)
  return &groups_;
}
inline const ::MurmurRPC::ACL_Group& Authenticator_Response_Authenticate::groups(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Authenticate.groups)
  return groups_.Get(index);
}
inline ::MurmurRPC::ACL_Group* Authenticator_Response_Authenticate::add_groups() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Authenticator.Response.Authenticate.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::ACL_Group >&
Authenticator_Response_Authenticate::groups() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Authenticator.Response.Authenticate.groups)
  return groups_;
}

// -------------------------------------------------------------------

// Authenticator_Response_Find

// optional .MurmurRPC.DatabaseUser user = 1;
inline bool Authenticator_Response_Find::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Find::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Find::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Find::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Response_Find::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Response_Find::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Find.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Find::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.Find.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Find::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Find.user)
  return user_;
}
inline void Authenticator_Response_Find::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.Find.user)
}

// -------------------------------------------------------------------

// Authenticator_Response_Query

// repeated .MurmurRPC.DatabaseUser users = 1;
inline int Authenticator_Response_Query::users_size() const {
  return users_.size();
}
inline void Authenticator_Response_Query::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Query::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Query.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
Authenticator_Response_Query::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.Authenticator.Response.Query.users)
  return &users_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Response_Query::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Query.users)
  return users_.Get(index);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Query::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.Authenticator.Response.Query.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
Authenticator_Response_Query::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.Authenticator.Response.Query.users)
  return users_;
}

// -------------------------------------------------------------------

// Authenticator_Response_Register

// optional .MurmurRPC.Authenticator.Response.Status status = 1;
inline bool Authenticator_Response_Register::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Response_Register::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Response_Register::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Response_Register::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::MurmurRPC::Authenticator_Response_Status Authenticator_Response_Register::status() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Register.status)
  return static_cast< ::MurmurRPC::Authenticator_Response_Status >(status_);
}
inline void Authenticator_Response_Register::set_status(::MurmurRPC::Authenticator_Response_Status value) {
  assert(::MurmurRPC::Authenticator_Response_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Register.status)
}

// optional .MurmurRPC.DatabaseUser user = 2;
inline bool Authenticator_Response_Register::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Register::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Register::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Register::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Response_Register::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::DatabaseUser& Authenticator_Response_Register::user() const {
  const ::MurmurRPC::DatabaseUser* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Register.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::DatabaseUser*>(
      &::MurmurRPC::_DatabaseUser_default_instance_);
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Register::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.Register.user)
  clear_has_user();
  ::MurmurRPC::DatabaseUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::DatabaseUser* Authenticator_Response_Register::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::DatabaseUser>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.Register.user)
  return user_;
}
inline void Authenticator_Response_Register::set_allocated_user(::MurmurRPC::DatabaseUser* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.Register.user)
}

// -------------------------------------------------------------------

// Authenticator_Response_Deregister

// optional .MurmurRPC.Authenticator.Response.Status status = 1;
inline bool Authenticator_Response_Deregister::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Deregister::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Deregister::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Deregister::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::MurmurRPC::Authenticator_Response_Status Authenticator_Response_Deregister::status() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Deregister.status)
  return static_cast< ::MurmurRPC::Authenticator_Response_Status >(status_);
}
inline void Authenticator_Response_Deregister::set_status(::MurmurRPC::Authenticator_Response_Status value) {
  assert(::MurmurRPC::Authenticator_Response_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Deregister.status)
}

// -------------------------------------------------------------------

// Authenticator_Response_Update

// optional .MurmurRPC.Authenticator.Response.Status status = 1;
inline bool Authenticator_Response_Update::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response_Update::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response_Update::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response_Update::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::MurmurRPC::Authenticator_Response_Status Authenticator_Response_Update::status() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.Update.status)
  return static_cast< ::MurmurRPC::Authenticator_Response_Status >(status_);
}
inline void Authenticator_Response_Update::set_status(::MurmurRPC::Authenticator_Response_Status value) {
  assert(::MurmurRPC::Authenticator_Response_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.Authenticator.Response.Update.status)
}

// -------------------------------------------------------------------

// Authenticator_Response

// optional .MurmurRPC.Authenticator.Response.Initialize initialize = 1;
inline bool Authenticator_Response::has_initialize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticator_Response::set_has_initialize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticator_Response::clear_has_initialize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticator_Response::clear_initialize() {
  if (initialize_ != NULL) initialize_->Clear();
  clear_has_initialize();
}
inline const ::MurmurRPC::Authenticator_Response_Initialize& Authenticator_Response::_internal_initialize() const {
  return *initialize_;
}
inline const ::MurmurRPC::Authenticator_Response_Initialize& Authenticator_Response::initialize() const {
  const ::MurmurRPC::Authenticator_Response_Initialize* p = initialize_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.initialize)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Initialize*>(
      &::MurmurRPC::_Authenticator_Response_Initialize_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Initialize* Authenticator_Response::release_initialize() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.initialize)
  clear_has_initialize();
  ::MurmurRPC::Authenticator_Response_Initialize* temp = initialize_;
  initialize_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Initialize* Authenticator_Response::mutable_initialize() {
  set_has_initialize();
  if (initialize_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Initialize>(GetArenaNoVirtual());
    initialize_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.initialize)
  return initialize_;
}
inline void Authenticator_Response::set_allocated_initialize(::MurmurRPC::Authenticator_Response_Initialize* initialize) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete initialize_;
  }
  if (initialize) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      initialize = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, initialize, submessage_arena);
    }
    set_has_initialize();
  } else {
    clear_has_initialize();
  }
  initialize_ = initialize;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.initialize)
}

// optional .MurmurRPC.Authenticator.Response.Authenticate authenticate = 2;
inline bool Authenticator_Response::has_authenticate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticator_Response::set_has_authenticate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticator_Response::clear_has_authenticate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticator_Response::clear_authenticate() {
  if (authenticate_ != NULL) authenticate_->Clear();
  clear_has_authenticate();
}
inline const ::MurmurRPC::Authenticator_Response_Authenticate& Authenticator_Response::_internal_authenticate() const {
  return *authenticate_;
}
inline const ::MurmurRPC::Authenticator_Response_Authenticate& Authenticator_Response::authenticate() const {
  const ::MurmurRPC::Authenticator_Response_Authenticate* p = authenticate_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.authenticate)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Authenticate*>(
      &::MurmurRPC::_Authenticator_Response_Authenticate_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Authenticate* Authenticator_Response::release_authenticate() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.authenticate)
  clear_has_authenticate();
  ::MurmurRPC::Authenticator_Response_Authenticate* temp = authenticate_;
  authenticate_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Authenticate* Authenticator_Response::mutable_authenticate() {
  set_has_authenticate();
  if (authenticate_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Authenticate>(GetArenaNoVirtual());
    authenticate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.authenticate)
  return authenticate_;
}
inline void Authenticator_Response::set_allocated_authenticate(::MurmurRPC::Authenticator_Response_Authenticate* authenticate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authenticate_;
  }
  if (authenticate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authenticate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authenticate, submessage_arena);
    }
    set_has_authenticate();
  } else {
    clear_has_authenticate();
  }
  authenticate_ = authenticate;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.authenticate)
}

// optional .MurmurRPC.Authenticator.Response.Find find = 3;
inline bool Authenticator_Response::has_find() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Authenticator_Response::set_has_find() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Authenticator_Response::clear_has_find() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Authenticator_Response::clear_find() {
  if (find_ != NULL) find_->Clear();
  clear_has_find();
}
inline const ::MurmurRPC::Authenticator_Response_Find& Authenticator_Response::_internal_find() const {
  return *find_;
}
inline const ::MurmurRPC::Authenticator_Response_Find& Authenticator_Response::find() const {
  const ::MurmurRPC::Authenticator_Response_Find* p = find_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.find)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Find*>(
      &::MurmurRPC::_Authenticator_Response_Find_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Find* Authenticator_Response::release_find() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.find)
  clear_has_find();
  ::MurmurRPC::Authenticator_Response_Find* temp = find_;
  find_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Find* Authenticator_Response::mutable_find() {
  set_has_find();
  if (find_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Find>(GetArenaNoVirtual());
    find_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.find)
  return find_;
}
inline void Authenticator_Response::set_allocated_find(::MurmurRPC::Authenticator_Response_Find* find) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete find_;
  }
  if (find) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      find = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, find, submessage_arena);
    }
    set_has_find();
  } else {
    clear_has_find();
  }
  find_ = find;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.find)
}

// optional .MurmurRPC.Authenticator.Response.Query query = 4;
inline bool Authenticator_Response::has_query() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Authenticator_Response::set_has_query() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Authenticator_Response::clear_has_query() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Authenticator_Response::clear_query() {
  if (query_ != NULL) query_->Clear();
  clear_has_query();
}
inline const ::MurmurRPC::Authenticator_Response_Query& Authenticator_Response::_internal_query() const {
  return *query_;
}
inline const ::MurmurRPC::Authenticator_Response_Query& Authenticator_Response::query() const {
  const ::MurmurRPC::Authenticator_Response_Query* p = query_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.query)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Query*>(
      &::MurmurRPC::_Authenticator_Response_Query_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Query* Authenticator_Response::release_query() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.query)
  clear_has_query();
  ::MurmurRPC::Authenticator_Response_Query* temp = query_;
  query_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Query* Authenticator_Response::mutable_query() {
  set_has_query();
  if (query_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Query>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.query)
  return query_;
}
inline void Authenticator_Response::set_allocated_query(::MurmurRPC::Authenticator_Response_Query* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete query_;
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    set_has_query();
  } else {
    clear_has_query();
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.query)
}

// optional .MurmurRPC.Authenticator.Response.Register register = 5;
inline bool Authenticator_Response::has_register_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Authenticator_Response::set_has_register_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Authenticator_Response::clear_has_register_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Authenticator_Response::clear_register_() {
  if (register__ != NULL) register__->Clear();
  clear_has_register_();
}
inline const ::MurmurRPC::Authenticator_Response_Register& Authenticator_Response::_internal_register_() const {
  return *register__;
}
inline const ::MurmurRPC::Authenticator_Response_Register& Authenticator_Response::register_() const {
  const ::MurmurRPC::Authenticator_Response_Register* p = register__;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.register)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Register*>(
      &::MurmurRPC::_Authenticator_Response_Register_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Register* Authenticator_Response::release_register_() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.register)
  clear_has_register_();
  ::MurmurRPC::Authenticator_Response_Register* temp = register__;
  register__ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Register* Authenticator_Response::mutable_register_() {
  set_has_register_();
  if (register__ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Register>(GetArenaNoVirtual());
    register__ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.register)
  return register__;
}
inline void Authenticator_Response::set_allocated_register_(::MurmurRPC::Authenticator_Response_Register* register_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete register__;
  }
  if (register_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      register_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, register_, submessage_arena);
    }
    set_has_register_();
  } else {
    clear_has_register_();
  }
  register__ = register_;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.register)
}

// optional .MurmurRPC.Authenticator.Response.Deregister deregister = 6;
inline bool Authenticator_Response::has_deregister() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Authenticator_Response::set_has_deregister() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Authenticator_Response::clear_has_deregister() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Authenticator_Response::clear_deregister() {
  if (deregister_ != NULL) deregister_->Clear();
  clear_has_deregister();
}
inline const ::MurmurRPC::Authenticator_Response_Deregister& Authenticator_Response::_internal_deregister() const {
  return *deregister_;
}
inline const ::MurmurRPC::Authenticator_Response_Deregister& Authenticator_Response::deregister() const {
  const ::MurmurRPC::Authenticator_Response_Deregister* p = deregister_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.deregister)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Deregister*>(
      &::MurmurRPC::_Authenticator_Response_Deregister_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Deregister* Authenticator_Response::release_deregister() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.deregister)
  clear_has_deregister();
  ::MurmurRPC::Authenticator_Response_Deregister* temp = deregister_;
  deregister_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Deregister* Authenticator_Response::mutable_deregister() {
  set_has_deregister();
  if (deregister_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Deregister>(GetArenaNoVirtual());
    deregister_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.deregister)
  return deregister_;
}
inline void Authenticator_Response::set_allocated_deregister(::MurmurRPC::Authenticator_Response_Deregister* deregister) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete deregister_;
  }
  if (deregister) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deregister = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deregister, submessage_arena);
    }
    set_has_deregister();
  } else {
    clear_has_deregister();
  }
  deregister_ = deregister;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.deregister)
}

// optional .MurmurRPC.Authenticator.Response.Update update = 7;
inline bool Authenticator_Response::has_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Authenticator_Response::set_has_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Authenticator_Response::clear_has_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Authenticator_Response::clear_update() {
  if (update_ != NULL) update_->Clear();
  clear_has_update();
}
inline const ::MurmurRPC::Authenticator_Response_Update& Authenticator_Response::_internal_update() const {
  return *update_;
}
inline const ::MurmurRPC::Authenticator_Response_Update& Authenticator_Response::update() const {
  const ::MurmurRPC::Authenticator_Response_Update* p = update_;
  // @@protoc_insertion_point(field_get:MurmurRPC.Authenticator.Response.update)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Authenticator_Response_Update*>(
      &::MurmurRPC::_Authenticator_Response_Update_default_instance_);
}
inline ::MurmurRPC::Authenticator_Response_Update* Authenticator_Response::release_update() {
  // @@protoc_insertion_point(field_release:MurmurRPC.Authenticator.Response.update)
  clear_has_update();
  ::MurmurRPC::Authenticator_Response_Update* temp = update_;
  update_ = NULL;
  return temp;
}
inline ::MurmurRPC::Authenticator_Response_Update* Authenticator_Response::mutable_update() {
  set_has_update();
  if (update_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Authenticator_Response_Update>(GetArenaNoVirtual());
    update_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.Authenticator.Response.update)
  return update_;
}
inline void Authenticator_Response::set_allocated_update(::MurmurRPC::Authenticator_Response_Update* update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_;
  }
  if (update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update, submessage_arena);
    }
    set_has_update();
  } else {
    clear_has_update();
  }
  update_ = update;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.Authenticator.Response.update)
}

// -------------------------------------------------------------------

// Authenticator

// -------------------------------------------------------------------

// DatabaseUser_Query

// optional .MurmurRPC.Server server = 1;
inline bool DatabaseUser_Query::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseUser_Query::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseUser_Query::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseUser_Query::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& DatabaseUser_Query::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& DatabaseUser_Query::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.Query.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* DatabaseUser_Query::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.Query.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* DatabaseUser_Query::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.Query.server)
  return server_;
}
inline void DatabaseUser_Query::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.Query.server)
}

// optional string filter = 2;
inline bool DatabaseUser_Query::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseUser_Query::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseUser_Query::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseUser_Query::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filter();
}
inline const ::std::string& DatabaseUser_Query::filter() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.Query.filter)
  return filter_.GetNoArena();
}
inline void DatabaseUser_Query::set_filter(const ::std::string& value) {
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.Query.filter)
}
#if LANG_CXX11
inline void DatabaseUser_Query::set_filter(::std::string&& value) {
  set_has_filter();
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.Query.filter)
}
#endif
inline void DatabaseUser_Query::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.Query.filter)
}
inline void DatabaseUser_Query::set_filter(const char* value, size_t size) {
  set_has_filter();
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.Query.filter)
}
inline ::std::string* DatabaseUser_Query::mutable_filter() {
  set_has_filter();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.Query.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser_Query::release_filter() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.Query.filter)
  if (!has_filter()) {
    return NULL;
  }
  clear_has_filter();
  return filter_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser_Query::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.Query.filter)
}

// -------------------------------------------------------------------

// DatabaseUser_List

// optional .MurmurRPC.Server server = 1;
inline bool DatabaseUser_List::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseUser_List::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseUser_List::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseUser_List::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& DatabaseUser_List::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& DatabaseUser_List::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.List.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* DatabaseUser_List::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.List.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* DatabaseUser_List::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.List.server)
  return server_;
}
inline void DatabaseUser_List::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.List.server)
}

// repeated .MurmurRPC.DatabaseUser users = 2;
inline int DatabaseUser_List::users_size() const {
  return users_.size();
}
inline void DatabaseUser_List::clear_users() {
  users_.Clear();
}
inline ::MurmurRPC::DatabaseUser* DatabaseUser_List::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.List.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >*
DatabaseUser_List::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MurmurRPC.DatabaseUser.List.users)
  return &users_;
}
inline const ::MurmurRPC::DatabaseUser& DatabaseUser_List::users(int index) const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.List.users)
  return users_.Get(index);
}
inline ::MurmurRPC::DatabaseUser* DatabaseUser_List::add_users() {
  // @@protoc_insertion_point(field_add:MurmurRPC.DatabaseUser.List.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MurmurRPC::DatabaseUser >&
DatabaseUser_List::users() const {
  // @@protoc_insertion_point(field_list:MurmurRPC.DatabaseUser.List.users)
  return users_;
}

// -------------------------------------------------------------------

// DatabaseUser_Verify

// optional .MurmurRPC.Server server = 1;
inline bool DatabaseUser_Verify::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseUser_Verify::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseUser_Verify::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseUser_Verify::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& DatabaseUser_Verify::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& DatabaseUser_Verify::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.Verify.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* DatabaseUser_Verify::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.Verify.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* DatabaseUser_Verify::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.Verify.server)
  return server_;
}
inline void DatabaseUser_Verify::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.Verify.server)
}

// optional string name = 2;
inline bool DatabaseUser_Verify::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseUser_Verify::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseUser_Verify::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseUser_Verify::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DatabaseUser_Verify::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.Verify.name)
  return name_.GetNoArena();
}
inline void DatabaseUser_Verify::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.Verify.name)
}
#if LANG_CXX11
inline void DatabaseUser_Verify::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.Verify.name)
}
#endif
inline void DatabaseUser_Verify::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.Verify.name)
}
inline void DatabaseUser_Verify::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.Verify.name)
}
inline ::std::string* DatabaseUser_Verify::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.Verify.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser_Verify::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.Verify.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser_Verify::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.Verify.name)
}

// optional string password = 3;
inline bool DatabaseUser_Verify::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseUser_Verify::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseUser_Verify::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseUser_Verify::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DatabaseUser_Verify::password() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.Verify.password)
  return password_.GetNoArena();
}
inline void DatabaseUser_Verify::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.Verify.password)
}
#if LANG_CXX11
inline void DatabaseUser_Verify::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.Verify.password)
}
#endif
inline void DatabaseUser_Verify::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.Verify.password)
}
inline void DatabaseUser_Verify::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.Verify.password)
}
inline ::std::string* DatabaseUser_Verify::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.Verify.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser_Verify::release_password() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.Verify.password)
  if (!has_password()) {
    return NULL;
  }
  clear_has_password();
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser_Verify::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.Verify.password)
}

// -------------------------------------------------------------------

// DatabaseUser

// optional .MurmurRPC.Server server = 1;
inline bool DatabaseUser::has_server() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DatabaseUser::set_has_server() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DatabaseUser::clear_has_server() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DatabaseUser::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& DatabaseUser::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& DatabaseUser::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* DatabaseUser::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* DatabaseUser::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.server)
  return server_;
}
inline void DatabaseUser::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.server)
}

// optional uint32 id = 2;
inline bool DatabaseUser::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DatabaseUser::set_has_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DatabaseUser::clear_has_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DatabaseUser::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 DatabaseUser::id() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.id)
  return id_;
}
inline void DatabaseUser::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.id)
}

// optional string name = 3;
inline bool DatabaseUser::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseUser::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseUser::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DatabaseUser::name() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.name)
  return name_.GetNoArena();
}
inline void DatabaseUser::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.name)
}
#if LANG_CXX11
inline void DatabaseUser::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.name)
}
#endif
inline void DatabaseUser::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.name)
}
inline void DatabaseUser::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.name)
}
inline ::std::string* DatabaseUser::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_name() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.name)
}

// optional string email = 4;
inline bool DatabaseUser::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseUser::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseUser::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseUser::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& DatabaseUser::email() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.email)
  return email_.GetNoArena();
}
inline void DatabaseUser::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.email)
}
#if LANG_CXX11
inline void DatabaseUser::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.email)
}
#endif
inline void DatabaseUser::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.email)
}
inline void DatabaseUser::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.email)
}
inline ::std::string* DatabaseUser::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_email() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.email)
  if (!has_email()) {
    return NULL;
  }
  clear_has_email();
  return email_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.email)
}

// optional string comment = 5;
inline bool DatabaseUser::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseUser::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseUser::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseUser::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& DatabaseUser::comment() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.comment)
  return comment_.GetNoArena();
}
inline void DatabaseUser::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.comment)
}
#if LANG_CXX11
inline void DatabaseUser::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.comment)
}
#endif
inline void DatabaseUser::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.comment)
}
inline void DatabaseUser::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.comment)
}
inline ::std::string* DatabaseUser::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_comment() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.comment)
  if (!has_comment()) {
    return NULL;
  }
  clear_has_comment();
  return comment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.comment)
}

// optional string hash = 6;
inline bool DatabaseUser::has_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatabaseUser::set_has_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatabaseUser::clear_has_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatabaseUser::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& DatabaseUser::hash() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.hash)
  return hash_.GetNoArena();
}
inline void DatabaseUser::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.hash)
}
#if LANG_CXX11
inline void DatabaseUser::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.hash)
}
#endif
inline void DatabaseUser::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.hash)
}
inline void DatabaseUser::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.hash)
}
inline ::std::string* DatabaseUser::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_hash() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.hash)
  if (!has_hash()) {
    return NULL;
  }
  clear_has_hash();
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.hash)
}

// optional string password = 7;
inline bool DatabaseUser::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatabaseUser::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatabaseUser::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatabaseUser::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DatabaseUser::password() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.password)
  return password_.GetNoArena();
}
inline void DatabaseUser::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.password)
}
#if LANG_CXX11
inline void DatabaseUser::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.password)
}
#endif
inline void DatabaseUser::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.password)
}
inline void DatabaseUser::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.password)
}
inline ::std::string* DatabaseUser::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_password() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.password)
  if (!has_password()) {
    return NULL;
  }
  clear_has_password();
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.password)
}

// optional string last_active = 8;
inline bool DatabaseUser::has_last_active() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DatabaseUser::set_has_last_active() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DatabaseUser::clear_has_last_active() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DatabaseUser::clear_last_active() {
  last_active_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_last_active();
}
inline const ::std::string& DatabaseUser::last_active() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.last_active)
  return last_active_.GetNoArena();
}
inline void DatabaseUser::set_last_active(const ::std::string& value) {
  set_has_last_active();
  last_active_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.last_active)
}
#if LANG_CXX11
inline void DatabaseUser::set_last_active(::std::string&& value) {
  set_has_last_active();
  last_active_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.last_active)
}
#endif
inline void DatabaseUser::set_last_active(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_last_active();
  last_active_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.last_active)
}
inline void DatabaseUser::set_last_active(const char* value, size_t size) {
  set_has_last_active();
  last_active_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.last_active)
}
inline ::std::string* DatabaseUser::mutable_last_active() {
  set_has_last_active();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.last_active)
  return last_active_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_last_active() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.last_active)
  if (!has_last_active()) {
    return NULL;
  }
  clear_has_last_active();
  return last_active_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_last_active(::std::string* last_active) {
  if (last_active != NULL) {
    set_has_last_active();
  } else {
    clear_has_last_active();
  }
  last_active_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_active);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.last_active)
}

// optional bytes texture = 9;
inline bool DatabaseUser::has_texture() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DatabaseUser::set_has_texture() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DatabaseUser::clear_has_texture() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DatabaseUser::clear_texture() {
  texture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_texture();
}
inline const ::std::string& DatabaseUser::texture() const {
  // @@protoc_insertion_point(field_get:MurmurRPC.DatabaseUser.texture)
  return texture_.GetNoArena();
}
inline void DatabaseUser::set_texture(const ::std::string& value) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MurmurRPC.DatabaseUser.texture)
}
#if LANG_CXX11
inline void DatabaseUser::set_texture(::std::string&& value) {
  set_has_texture();
  texture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MurmurRPC.DatabaseUser.texture)
}
#endif
inline void DatabaseUser::set_texture(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MurmurRPC.DatabaseUser.texture)
}
inline void DatabaseUser::set_texture(const void* value, size_t size) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MurmurRPC.DatabaseUser.texture)
}
inline ::std::string* DatabaseUser::mutable_texture() {
  set_has_texture();
  // @@protoc_insertion_point(field_mutable:MurmurRPC.DatabaseUser.texture)
  return texture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabaseUser::release_texture() {
  // @@protoc_insertion_point(field_release:MurmurRPC.DatabaseUser.texture)
  if (!has_texture()) {
    return NULL;
  }
  clear_has_texture();
  return texture_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabaseUser::set_allocated_texture(::std::string* texture) {
  if (texture != NULL) {
    set_has_texture();
  } else {
    clear_has_texture();
  }
  texture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture);
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.DatabaseUser.texture)
}

// -------------------------------------------------------------------

// RedirectWhisperGroup

// optional .MurmurRPC.Server server = 1;
inline bool RedirectWhisperGroup::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectWhisperGroup::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectWhisperGroup::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectWhisperGroup::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::MurmurRPC::Server& RedirectWhisperGroup::_internal_server() const {
  return *server_;
}
inline const ::MurmurRPC::Server& RedirectWhisperGroup::server() const {
  const ::MurmurRPC::Server* p = server_;
  // @@protoc_insertion_point(field_get:MurmurRPC.RedirectWhisperGroup.server)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::Server*>(
      &::MurmurRPC::_Server_default_instance_);
}
inline ::MurmurRPC::Server* RedirectWhisperGroup::release_server() {
  // @@protoc_insertion_point(field_release:MurmurRPC.RedirectWhisperGroup.server)
  clear_has_server();
  ::MurmurRPC::Server* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::MurmurRPC::Server* RedirectWhisperGroup::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::Server>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.RedirectWhisperGroup.server)
  return server_;
}
inline void RedirectWhisperGroup::set_allocated_server(::MurmurRPC::Server* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.RedirectWhisperGroup.server)
}

// optional .MurmurRPC.User user = 2;
inline bool RedirectWhisperGroup::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedirectWhisperGroup::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedirectWhisperGroup::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedirectWhisperGroup::clear_user() {
  if (user_ != NULL) user_->Clear();
  clear_has_user();
}
inline const ::MurmurRPC::User& RedirectWhisperGroup::_internal_user() const {
  return *user_;
}
inline const ::MurmurRPC::User& RedirectWhisperGroup::user() const {
  const ::MurmurRPC::User* p = user_;
  // @@protoc_insertion_point(field_get:MurmurRPC.RedirectWhisperGroup.user)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::User*>(
      &::MurmurRPC::_User_default_instance_);
}
inline ::MurmurRPC::User* RedirectWhisperGroup::release_user() {
  // @@protoc_insertion_point(field_release:MurmurRPC.RedirectWhisperGroup.user)
  clear_has_user();
  ::MurmurRPC::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::MurmurRPC::User* RedirectWhisperGroup::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.RedirectWhisperGroup.user)
  return user_;
}
inline void RedirectWhisperGroup::set_allocated_user(::MurmurRPC::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.RedirectWhisperGroup.user)
}

// optional .MurmurRPC.ACL.Group source = 3;
inline bool RedirectWhisperGroup::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedirectWhisperGroup::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedirectWhisperGroup::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedirectWhisperGroup::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::MurmurRPC::ACL_Group& RedirectWhisperGroup::_internal_source() const {
  return *source_;
}
inline const ::MurmurRPC::ACL_Group& RedirectWhisperGroup::source() const {
  const ::MurmurRPC::ACL_Group* p = source_;
  // @@protoc_insertion_point(field_get:MurmurRPC.RedirectWhisperGroup.source)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::ACL_Group*>(
      &::MurmurRPC::_ACL_Group_default_instance_);
}
inline ::MurmurRPC::ACL_Group* RedirectWhisperGroup::release_source() {
  // @@protoc_insertion_point(field_release:MurmurRPC.RedirectWhisperGroup.source)
  clear_has_source();
  ::MurmurRPC::ACL_Group* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::MurmurRPC::ACL_Group* RedirectWhisperGroup::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::ACL_Group>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.RedirectWhisperGroup.source)
  return source_;
}
inline void RedirectWhisperGroup::set_allocated_source(::MurmurRPC::ACL_Group* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.RedirectWhisperGroup.source)
}

// optional .MurmurRPC.ACL.Group target = 4;
inline bool RedirectWhisperGroup::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedirectWhisperGroup::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedirectWhisperGroup::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedirectWhisperGroup::clear_target() {
  if (target_ != NULL) target_->Clear();
  clear_has_target();
}
inline const ::MurmurRPC::ACL_Group& RedirectWhisperGroup::_internal_target() const {
  return *target_;
}
inline const ::MurmurRPC::ACL_Group& RedirectWhisperGroup::target() const {
  const ::MurmurRPC::ACL_Group* p = target_;
  // @@protoc_insertion_point(field_get:MurmurRPC.RedirectWhisperGroup.target)
  return p != NULL ? *p : *reinterpret_cast<const ::MurmurRPC::ACL_Group*>(
      &::MurmurRPC::_ACL_Group_default_instance_);
}
inline ::MurmurRPC::ACL_Group* RedirectWhisperGroup::release_target() {
  // @@protoc_insertion_point(field_release:MurmurRPC.RedirectWhisperGroup.target)
  clear_has_target();
  ::MurmurRPC::ACL_Group* temp = target_;
  target_ = NULL;
  return temp;
}
inline ::MurmurRPC::ACL_Group* RedirectWhisperGroup::mutable_target() {
  set_has_target();
  if (target_ == NULL) {
    auto* p = CreateMaybeMessage<::MurmurRPC::ACL_Group>(GetArenaNoVirtual());
    target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MurmurRPC.RedirectWhisperGroup.target)
  return target_;
}
inline void RedirectWhisperGroup::set_allocated_target(::MurmurRPC::ACL_Group* target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_;
  }
  if (target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    set_has_target();
  } else {
    clear_has_target();
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:MurmurRPC.RedirectWhisperGroup.target)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MurmurRPC

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MurmurRPC::Server_Event_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::Server_Event_Type>() {
  return ::MurmurRPC::Server_Event_Type_descriptor();
}
template <> struct is_proto_enum< ::MurmurRPC::Event_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::Event_Type>() {
  return ::MurmurRPC::Event_Type_descriptor();
}
template <> struct is_proto_enum< ::MurmurRPC::ContextAction_Context> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::ContextAction_Context>() {
  return ::MurmurRPC::ContextAction_Context_descriptor();
}
template <> struct is_proto_enum< ::MurmurRPC::TextMessage_Filter_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::TextMessage_Filter_Action>() {
  return ::MurmurRPC::TextMessage_Filter_Action_descriptor();
}
template <> struct is_proto_enum< ::MurmurRPC::ACL_Permission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::ACL_Permission>() {
  return ::MurmurRPC::ACL_Permission_descriptor();
}
template <> struct is_proto_enum< ::MurmurRPC::Authenticator_Response_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MurmurRPC::Authenticator_Response_Status>() {
  return ::MurmurRPC::Authenticator_Response_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_MurmurRPC_2eproto
