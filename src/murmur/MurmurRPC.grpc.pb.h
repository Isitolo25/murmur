// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: MurmurRPC.proto
// Original file comments:
// Copyright 2016-2021 The Mumble Developers. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file at the root of the
// Mumble source tree or at <https://www.mumble.info/LICENSE>.
//
#ifndef GRPC_MurmurRPC_2eproto__INCLUDED
#define GRPC_MurmurRPC_2eproto__INCLUDED

#include "MurmurRPC.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace MurmurRPC {

class V1 final {
 public:
  static constexpr char const* service_full_name() {
    return "MurmurRPC.V1";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GetUptime returns murmur's uptime.
    virtual ::grpc::Status GetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Uptime* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>> AsyncGetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>>(AsyncGetUptimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>> PrepareAsyncGetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>>(PrepareAsyncGetUptimeRaw(context, request, cq));
    }
    // GetVersion returns murmur's version.
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Version* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>> AsyncGetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // Events returns a stream of murmur events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::Event>> Events(::grpc::ClientContext* context, const ::MurmurRPC::Void& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::Event>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>> AsyncEvents(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    //
    // Servers
    //
    //
    // ServerCreate creates a new virtual server. The returned server object
    // contains the newly created server's ID.
    virtual ::grpc::Status ServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Server* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>> AsyncServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>>(AsyncServerCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>> PrepareAsyncServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>>(PrepareAsyncServerCreateRaw(context, request, cq));
    }
    // ServerQuery returns a list of servers that match the given query.
    virtual ::grpc::Status ServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::MurmurRPC::Server_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>> AsyncServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>>(AsyncServerQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>> PrepareAsyncServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>>(PrepareAsyncServerQueryRaw(context, request, cq));
    }
    // ServerGet returns information about the given server.
    virtual ::grpc::Status ServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Server* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>> AsyncServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>>(AsyncServerGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>> PrepareAsyncServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>>(PrepareAsyncServerGetRaw(context, request, cq));
    }
    // ServerStart starts the given stopped server.
    virtual ::grpc::Status ServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncServerStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncServerStartRaw(context, request, cq));
    }
    // ServerStop stops the given virtual server.
    virtual ::grpc::Status ServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncServerStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncServerStopRaw(context, request, cq));
    }
    // ServerRemove removes the given virtual server and its configuration.
    virtual ::grpc::Status ServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncServerRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncServerRemoveRaw(context, request, cq));
    }
    // ServerEvents returns a stream of events that happen on the given server.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::Server_Event>> ServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::Server_Event>>(ServerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>> AsyncServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>>(AsyncServerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>> PrepareAsyncServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>>(PrepareAsyncServerEventsRaw(context, request, cq));
    }
    //
    // ContextActions
    //
    //
    // ContextActionAdd adds a context action to the given user's client. The
    // following ContextAction fields must be set:
    //   context, action, text, and user.
    //
    // Added context actions are valid until:
    //  - The context action is removed with ContextActionRemove, or
    //  - The user disconnects from the server, or
    //  - The server stops.
    virtual ::grpc::Status ContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncContextActionAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncContextActionAddRaw(context, request, cq));
    }
    // ContextActionRemove removes a context action from the given user's client.
    // The following ContextAction must be set:
    //   action
    // If no user is given, the context action is removed from all users.
    virtual ::grpc::Status ContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncContextActionRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncContextActionRemoveRaw(context, request, cq));
    }
    // ContextActionEvents returns a stream of context action events that are
    // triggered by users.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::ContextAction>> ContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::MurmurRPC::ContextAction>>(ContextActionEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>> AsyncContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>>(AsyncContextActionEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>> PrepareAsyncContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>>(PrepareAsyncContextActionEventsRaw(context, request, cq));
    }
    //
    // TextMessage
    //
    //
    // TextMessageSend sends the given TextMessage to the server.
    //
    // If no users, channels, or trees are added to the TextMessage, the message
    // will be broadcast the entire server. Otherwise, the message will be
    // targeted to the specified users, channels, and trees.
    virtual ::grpc::Status TextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncTextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncTextMessageSendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncTextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncTextMessageSendRaw(context, request, cq));
    }
    // TextMessageFilter filters text messages on a given server.
    // TextMessageFilter filters text messages for a given server.
    //
    // When a filter stream is active, text messages sent from users to the
    // server are sent over the stream. The RPC client then sends a message back
    // on the same stream, containing an action: whether the message should be
    // accepted, rejected, or dropped.
    //
    // To activate the filter stream, an initial TextMessage.Filter message must
    // be sent that contains the server on which the filter will be active.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> TextMessageFilter(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(TextMessageFilterRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> AsyncTextMessageFilter(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(AsyncTextMessageFilterRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> PrepareAsyncTextMessageFilter(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(PrepareAsyncTextMessageFilterRaw(context, cq));
    }
    //
    // Logs
    //
    //
    // LogQuery returns a list of log entries from the given server.
    //
    // To get the total number of log entries, omit min and/or max from the
    // query.
    virtual ::grpc::Status LogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::MurmurRPC::Log_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>> AsyncLogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>>(AsyncLogQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>> PrepareAsyncLogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>>(PrepareAsyncLogQueryRaw(context, request, cq));
    }
    //
    // Config
    //
    //
    // ConfigGet returns the explicitly set configuration for the given server.
    virtual ::grpc::Status ConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Config* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>> AsyncConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>>(AsyncConfigGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>> PrepareAsyncConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>>(PrepareAsyncConfigGetRaw(context, request, cq));
    }
    // ConfigGetField returns the configuration value for the given key.
    virtual ::grpc::Status ConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::MurmurRPC::Config_Field* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>> AsyncConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>>(AsyncConfigGetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>> PrepareAsyncConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>>(PrepareAsyncConfigGetFieldRaw(context, request, cq));
    }
    // ConfigSetField sets the configuration value to the given value.
    virtual ::grpc::Status ConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncConfigSetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncConfigSetFieldRaw(context, request, cq));
    }
    // ConfigGetDefault returns the default server configuration.
    virtual ::grpc::Status ConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Config* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>> AsyncConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>>(AsyncConfigGetDefaultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>> PrepareAsyncConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>>(PrepareAsyncConfigGetDefaultRaw(context, request, cq));
    }
    //
    // Channels
    //
    //
    // ChannelQuery returns a list of channels that match the given query.
    virtual ::grpc::Status ChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::MurmurRPC::Channel_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>> AsyncChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>>(AsyncChannelQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>> PrepareAsyncChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>>(PrepareAsyncChannelQueryRaw(context, request, cq));
    }
    // ChannelGet returns the channel with the given ID.
    virtual ::grpc::Status ChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> AsyncChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(AsyncChannelGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> PrepareAsyncChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(PrepareAsyncChannelGetRaw(context, request, cq));
    }
    // ChannelAdd adds the channel to the given server. The parent and name of
    // the channel must be set.
    virtual ::grpc::Status ChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> AsyncChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(AsyncChannelAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> PrepareAsyncChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(PrepareAsyncChannelAddRaw(context, request, cq));
    }
    // ChannelRemove removes the given channel from the server.
    virtual ::grpc::Status ChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncChannelRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncChannelRemoveRaw(context, request, cq));
    }
    // ChannelUpdate updates the given channel's attributes. Only the fields that
    // are set will be updated.
    virtual ::grpc::Status ChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> AsyncChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(AsyncChannelUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>> PrepareAsyncChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>>(PrepareAsyncChannelUpdateRaw(context, request, cq));
    }
    //
    // Users
    //
    //
    // UserQuery returns a list of connected users who match the given query.
    virtual ::grpc::Status UserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::MurmurRPC::User_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>> AsyncUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>>(AsyncUserQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>> PrepareAsyncUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>>(PrepareAsyncUserQueryRaw(context, request, cq));
    }
    // UserGet returns information on the connected user, given by the user's
    // session or name.
    virtual ::grpc::Status UserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::MurmurRPC::User* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>> AsyncUserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>>(AsyncUserGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>> PrepareAsyncUserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>>(PrepareAsyncUserGetRaw(context, request, cq));
    }
    // UserUpdate changes the given user's state. Only the following fields can
    // be changed:
    //   name, mute, deaf, suppress, priority_speaker, channel, comment.
    virtual ::grpc::Status UserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::MurmurRPC::User* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>> AsyncUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>>(AsyncUserUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>> PrepareAsyncUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>>(PrepareAsyncUserUpdateRaw(context, request, cq));
    }
    // UserKick kicks the user from the server.
    virtual ::grpc::Status UserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncUserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncUserKickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncUserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncUserKickRaw(context, request, cq));
    }
    //
    // Tree
    //
    //
    // TreeQuery returns a representation of the given server's channel/user
    // tree.
    virtual ::grpc::Status TreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::MurmurRPC::Tree* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>> AsyncTreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>>(AsyncTreeQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>> PrepareAsyncTreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>>(PrepareAsyncTreeQueryRaw(context, request, cq));
    }
    //
    // Bans
    //
    //
    // BansGet returns a list of bans for the given server.
    virtual ::grpc::Status BansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::MurmurRPC::Ban_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>> AsyncBansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>>(AsyncBansGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>> PrepareAsyncBansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>>(PrepareAsyncBansGetRaw(context, request, cq));
    }
    // BansSet replaces the server's ban list with the given list.
    virtual ::grpc::Status BansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncBansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncBansSetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncBansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncBansSetRaw(context, request, cq));
    }
    //
    // ACL
    //
    //
    // ACLGet returns the ACL for the given channel.
    virtual ::grpc::Status ACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::ACL_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>> AsyncACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>>(AsyncACLGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>> PrepareAsyncACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>>(PrepareAsyncACLGetRaw(context, request, cq));
    }
    // ACLSet overrides the ACL of the given channel to what is provided.
    virtual ::grpc::Status ACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncACLSetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncACLSetRaw(context, request, cq));
    }
    // ACLGetEffectivePermissions returns the effective permissions for the given
    // user in the given channel.
    virtual ::grpc::Status ACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::MurmurRPC::ACL* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>> AsyncACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>>(AsyncACLGetEffectivePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>> PrepareAsyncACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>>(PrepareAsyncACLGetEffectivePermissionsRaw(context, request, cq));
    }
    // ACLAddTemporaryGroup adds a user to a temporary group.
    virtual ::grpc::Status ACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncACLAddTemporaryGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncACLAddTemporaryGroupRaw(context, request, cq));
    }
    // ACLRemoveTemporaryGroup removes a user from a temporary group.
    virtual ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncACLRemoveTemporaryGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncACLRemoveTemporaryGroupRaw(context, request, cq));
    }
    //
    // Authenticator
    //
    //
    // AuthenticatorStream opens an authentication stream to the server.
    //
    // There can only be one RPC client with an open Stream. If a new
    // authenticator connects, the open connected will be closed.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> AuthenticatorStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(AuthenticatorStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> AsyncAuthenticatorStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(AsyncAuthenticatorStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> PrepareAsyncAuthenticatorStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(PrepareAsyncAuthenticatorStreamRaw(context, cq));
    }
    //
    // Database
    //
    //
    // DatabaseUserQuery returns a list of registered users who match given
    // query.
    virtual ::grpc::Status DatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::MurmurRPC::DatabaseUser_List* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>> AsyncDatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>>(AsyncDatabaseUserQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>> PrepareAsyncDatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>>(PrepareAsyncDatabaseUserQueryRaw(context, request, cq));
    }
    // DatabaseUserGet returns the database user with the given ID.
    virtual ::grpc::Status DatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::DatabaseUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserGetRaw(context, request, cq));
    }
    // DatabaseUserUpdate updates the given database user.
    virtual ::grpc::Status DatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncDatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncDatabaseUserUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncDatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncDatabaseUserUpdateRaw(context, request, cq));
    }
    // DatabaseUserRegister registers a user with the given information on the
    // server. The returned DatabaseUser will contain the newly registered user's
    // ID.
    virtual ::grpc::Status DatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::DatabaseUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserRegisterRaw(context, request, cq));
    }
    // DatabaseUserDeregister deregisters the given user.
    virtual ::grpc::Status DatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncDatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncDatabaseUserDeregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncDatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncDatabaseUserDeregisterRaw(context, request, cq));
    }
    // DatabaseUserVerify verifies the that the given user-password pair is
    // correct.
    virtual ::grpc::Status DatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::MurmurRPC::DatabaseUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserVerifyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserVerifyRaw(context, request, cq));
    }
    //
    // Audio
    //
    //
    // AddRedirectWhisperGroup add a whisper targets redirection for the given
    // user. Whenever a user whispers to group "source", the whisper will be
    // redirected to group "target".
    virtual ::grpc::Status RedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncRedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncRedirectWhisperGroupAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncRedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncRedirectWhisperGroupAddRaw(context, request, cq));
    }
    // RemoveRedirectWhisperGroup removes a whisper target redirection for
    // the the given user.
    virtual ::grpc::Status RedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::MurmurRPC::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> AsyncRedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(AsyncRedirectWhisperGroupRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>> PrepareAsyncRedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>>(PrepareAsyncRedirectWhisperGroupRemoveRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // GetUptime returns murmur's uptime.
      virtual void GetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response, std::function<void(::grpc::Status)>) = 0;
      // GetVersion returns murmur's version.
      virtual void GetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response, std::function<void(::grpc::Status)>) = 0;
      // Events returns a stream of murmur events.
      //
      // Servers
      //
      //
      // ServerCreate creates a new virtual server. The returned server object
      // contains the newly created server's ID.
      virtual void ServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response, std::function<void(::grpc::Status)>) = 0;
      // ServerQuery returns a list of servers that match the given query.
      virtual void ServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response, std::function<void(::grpc::Status)>) = 0;
      // ServerGet returns information about the given server.
      virtual void ServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response, std::function<void(::grpc::Status)>) = 0;
      // ServerStart starts the given stopped server.
      virtual void ServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ServerStop stops the given virtual server.
      virtual void ServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ServerRemove removes the given virtual server and its configuration.
      virtual void ServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ServerEvents returns a stream of events that happen on the given server.
      //
      // ContextActions
      //
      //
      // ContextActionAdd adds a context action to the given user's client. The
      // following ContextAction fields must be set:
      //   context, action, text, and user.
      //
      // Added context actions are valid until:
      //  - The context action is removed with ContextActionRemove, or
      //  - The user disconnects from the server, or
      //  - The server stops.
      virtual void ContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ContextActionRemove removes a context action from the given user's client.
      // The following ContextAction must be set:
      //   action
      // If no user is given, the context action is removed from all users.
      virtual void ContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ContextActionEvents returns a stream of context action events that are
      // triggered by users.
      //
      // TextMessage
      //
      //
      // TextMessageSend sends the given TextMessage to the server.
      //
      // If no users, channels, or trees are added to the TextMessage, the message
      // will be broadcast the entire server. Otherwise, the message will be
      // targeted to the specified users, channels, and trees.
      virtual void TextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // TextMessageFilter filters text messages on a given server.
      // TextMessageFilter filters text messages for a given server.
      //
      // When a filter stream is active, text messages sent from users to the
      // server are sent over the stream. The RPC client then sends a message back
      // on the same stream, containing an action: whether the message should be
      // accepted, rejected, or dropped.
      //
      // To activate the filter stream, an initial TextMessage.Filter message must
      // be sent that contains the server on which the filter will be active.
      //
      // Logs
      //
      //
      // LogQuery returns a list of log entries from the given server.
      //
      // To get the total number of log entries, omit min and/or max from the
      // query.
      virtual void LogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Config
      //
      //
      // ConfigGet returns the explicitly set configuration for the given server.
      virtual void ConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response, std::function<void(::grpc::Status)>) = 0;
      // ConfigGetField returns the configuration value for the given key.
      virtual void ConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response, std::function<void(::grpc::Status)>) = 0;
      // ConfigSetField sets the configuration value to the given value.
      virtual void ConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ConfigGetDefault returns the default server configuration.
      virtual void ConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Channels
      //
      //
      // ChannelQuery returns a list of channels that match the given query.
      virtual void ChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response, std::function<void(::grpc::Status)>) = 0;
      // ChannelGet returns the channel with the given ID.
      virtual void ChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) = 0;
      // ChannelAdd adds the channel to the given server. The parent and name of
      // the channel must be set.
      virtual void ChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) = 0;
      // ChannelRemove removes the given channel from the server.
      virtual void ChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ChannelUpdate updates the given channel's attributes. Only the fields that
      // are set will be updated.
      virtual void ChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Users
      //
      //
      // UserQuery returns a list of connected users who match the given query.
      virtual void UserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response, std::function<void(::grpc::Status)>) = 0;
      // UserGet returns information on the connected user, given by the user's
      // session or name.
      virtual void UserGet(::grpc::ClientContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response, std::function<void(::grpc::Status)>) = 0;
      // UserUpdate changes the given user's state. Only the following fields can
      // be changed:
      //   name, mute, deaf, suppress, priority_speaker, channel, comment.
      virtual void UserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response, std::function<void(::grpc::Status)>) = 0;
      // UserKick kicks the user from the server.
      virtual void UserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Tree
      //
      //
      // TreeQuery returns a representation of the given server's channel/user
      // tree.
      virtual void TreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Bans
      //
      //
      // BansGet returns a list of bans for the given server.
      virtual void BansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response, std::function<void(::grpc::Status)>) = 0;
      // BansSet replaces the server's ban list with the given list.
      virtual void BansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      //
      // ACL
      //
      //
      // ACLGet returns the ACL for the given channel.
      virtual void ACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response, std::function<void(::grpc::Status)>) = 0;
      // ACLSet overrides the ACL of the given channel to what is provided.
      virtual void ACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ACLGetEffectivePermissions returns the effective permissions for the given
      // user in the given channel.
      virtual void ACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response, std::function<void(::grpc::Status)>) = 0;
      // ACLAddTemporaryGroup adds a user to a temporary group.
      virtual void ACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // ACLRemoveTemporaryGroup removes a user from a temporary group.
      virtual void ACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Authenticator
      //
      //
      // AuthenticatorStream opens an authentication stream to the server.
      //
      // There can only be one RPC client with an open Stream. If a new
      // authenticator connects, the open connected will be closed.
      //
      // Database
      //
      //
      // DatabaseUserQuery returns a list of registered users who match given
      // query.
      virtual void DatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response, std::function<void(::grpc::Status)>) = 0;
      // DatabaseUserGet returns the database user with the given ID.
      virtual void DatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) = 0;
      // DatabaseUserUpdate updates the given database user.
      virtual void DatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // DatabaseUserRegister registers a user with the given information on the
      // server. The returned DatabaseUser will contain the newly registered user's
      // ID.
      virtual void DatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) = 0;
      // DatabaseUserDeregister deregisters the given user.
      virtual void DatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // DatabaseUserVerify verifies the that the given user-password pair is
      // correct.
      virtual void DatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) = 0;
      //
      // Audio
      //
      //
      // AddRedirectWhisperGroup add a whisper targets redirection for the given
      // user. Whenever a user whispers to group "source", the whisper will be
      // redirected to group "target".
      virtual void RedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
      // RemoveRedirectWhisperGroup removes a whisper target redirection for
      // the the given user.
      virtual void RedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>* AsyncGetUptimeRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Uptime>* PrepareAsyncGetUptimeRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Version>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::MurmurRPC::Event>* EventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>* AsyncEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Event>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>* AsyncServerCreateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>* PrepareAsyncServerCreateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>* AsyncServerQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server_List>* PrepareAsyncServerQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>* AsyncServerGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Server>* PrepareAsyncServerGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncServerStartRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncServerStartRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncServerStopRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncServerStopRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncServerRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncServerRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::MurmurRPC::Server_Event>* ServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>* AsyncServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::Server_Event>* PrepareAsyncServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncContextActionAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncContextActionAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncContextActionRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncContextActionRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::MurmurRPC::ContextAction>* ContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>* AsyncContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::MurmurRPC::ContextAction>* PrepareAsyncContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncTextMessageSendRaw(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncTextMessageSendRaw(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* TextMessageFilterRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* AsyncTextMessageFilterRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* PrepareAsyncTextMessageFilterRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>* AsyncLogQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Log_List>* PrepareAsyncLogQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>* AsyncConfigGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>* PrepareAsyncConfigGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>* AsyncConfigGetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config_Field>* PrepareAsyncConfigGetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncConfigSetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncConfigSetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>* AsyncConfigGetDefaultRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Config>* PrepareAsyncConfigGetDefaultRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>* AsyncChannelQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel_List>* PrepareAsyncChannelQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* AsyncChannelGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* PrepareAsyncChannelGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* AsyncChannelAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* PrepareAsyncChannelAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncChannelRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncChannelRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* AsyncChannelUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Channel>* PrepareAsyncChannelUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>* AsyncUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User_List>* PrepareAsyncUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>* AsyncUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>* PrepareAsyncUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>* AsyncUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::User>* PrepareAsyncUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncUserKickRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncUserKickRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>* AsyncTreeQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Tree>* PrepareAsyncTreeQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>* AsyncBansGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Ban_List>* PrepareAsyncBansGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncBansSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncBansSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>* AsyncACLGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL_List>* PrepareAsyncACLGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncACLSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncACLSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>* AsyncACLGetEffectivePermissionsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::ACL>* PrepareAsyncACLGetEffectivePermissionsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncACLAddTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncACLAddTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncACLRemoveTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncACLRemoveTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* AuthenticatorStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* AsyncAuthenticatorStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* PrepareAsyncAuthenticatorStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>* AsyncDatabaseUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser_List>* PrepareAsyncDatabaseUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncDatabaseUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncDatabaseUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserRegisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserRegisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncDatabaseUserDeregisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncDatabaseUserDeregisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserVerifyRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserVerifyRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncRedirectWhisperGroupAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncRedirectWhisperGroupAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* AsyncRedirectWhisperGroupRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MurmurRPC::Void>* PrepareAsyncRedirectWhisperGroupRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Uptime* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>> AsyncGetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>>(AsyncGetUptimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>> PrepareAsyncGetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>>(PrepareAsyncGetUptimeRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Version* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>> AsyncGetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::Event>> Events(::grpc::ClientContext* context, const ::MurmurRPC::Void& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::Event>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Event>> AsyncEvents(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Event>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Event>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Event>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    ::grpc::Status ServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Server* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>> AsyncServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>>(AsyncServerCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>> PrepareAsyncServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>>(PrepareAsyncServerCreateRaw(context, request, cq));
    }
    ::grpc::Status ServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::MurmurRPC::Server_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>> AsyncServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>>(AsyncServerQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>> PrepareAsyncServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>>(PrepareAsyncServerQueryRaw(context, request, cq));
    }
    ::grpc::Status ServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Server* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>> AsyncServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>>(AsyncServerGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>> PrepareAsyncServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>>(PrepareAsyncServerGetRaw(context, request, cq));
    }
    ::grpc::Status ServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncServerStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncServerStartRaw(context, request, cq));
    }
    ::grpc::Status ServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncServerStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncServerStopRaw(context, request, cq));
    }
    ::grpc::Status ServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncServerRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncServerRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::Server_Event>> ServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::Server_Event>>(ServerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>> AsyncServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>>(AsyncServerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>> PrepareAsyncServerEvents(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>>(PrepareAsyncServerEventsRaw(context, request, cq));
    }
    ::grpc::Status ContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncContextActionAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncContextActionAddRaw(context, request, cq));
    }
    ::grpc::Status ContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncContextActionRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncContextActionRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::ContextAction>> ContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::MurmurRPC::ContextAction>>(ContextActionEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>> AsyncContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>>(AsyncContextActionEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>> PrepareAsyncContextActionEvents(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>>(PrepareAsyncContextActionEventsRaw(context, request, cq));
    }
    ::grpc::Status TextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncTextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncTextMessageSendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncTextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncTextMessageSendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> TextMessageFilter(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(TextMessageFilterRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> AsyncTextMessageFilter(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(AsyncTextMessageFilterRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>> PrepareAsyncTextMessageFilter(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>>(PrepareAsyncTextMessageFilterRaw(context, cq));
    }
    ::grpc::Status LogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::MurmurRPC::Log_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>> AsyncLogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>>(AsyncLogQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>> PrepareAsyncLogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>>(PrepareAsyncLogQueryRaw(context, request, cq));
    }
    ::grpc::Status ConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::MurmurRPC::Config* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>> AsyncConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>>(AsyncConfigGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>> PrepareAsyncConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>>(PrepareAsyncConfigGetRaw(context, request, cq));
    }
    ::grpc::Status ConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::MurmurRPC::Config_Field* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>> AsyncConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>>(AsyncConfigGetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>> PrepareAsyncConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>>(PrepareAsyncConfigGetFieldRaw(context, request, cq));
    }
    ::grpc::Status ConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncConfigSetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncConfigSetFieldRaw(context, request, cq));
    }
    ::grpc::Status ConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::MurmurRPC::Config* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>> AsyncConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>>(AsyncConfigGetDefaultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>> PrepareAsyncConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>>(PrepareAsyncConfigGetDefaultRaw(context, request, cq));
    }
    ::grpc::Status ChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::MurmurRPC::Channel_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>> AsyncChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>>(AsyncChannelQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>> PrepareAsyncChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>>(PrepareAsyncChannelQueryRaw(context, request, cq));
    }
    ::grpc::Status ChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> AsyncChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(AsyncChannelGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> PrepareAsyncChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(PrepareAsyncChannelGetRaw(context, request, cq));
    }
    ::grpc::Status ChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> AsyncChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(AsyncChannelAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> PrepareAsyncChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(PrepareAsyncChannelAddRaw(context, request, cq));
    }
    ::grpc::Status ChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncChannelRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncChannelRemoveRaw(context, request, cq));
    }
    ::grpc::Status ChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::Channel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> AsyncChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(AsyncChannelUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>> PrepareAsyncChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>>(PrepareAsyncChannelUpdateRaw(context, request, cq));
    }
    ::grpc::Status UserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::MurmurRPC::User_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>> AsyncUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>>(AsyncUserQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>> PrepareAsyncUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>>(PrepareAsyncUserQueryRaw(context, request, cq));
    }
    ::grpc::Status UserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::MurmurRPC::User* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>> AsyncUserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>>(AsyncUserGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>> PrepareAsyncUserGet(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>>(PrepareAsyncUserGetRaw(context, request, cq));
    }
    ::grpc::Status UserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::MurmurRPC::User* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>> AsyncUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>>(AsyncUserUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>> PrepareAsyncUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>>(PrepareAsyncUserUpdateRaw(context, request, cq));
    }
    ::grpc::Status UserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncUserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncUserKickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncUserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncUserKickRaw(context, request, cq));
    }
    ::grpc::Status TreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::MurmurRPC::Tree* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>> AsyncTreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>>(AsyncTreeQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>> PrepareAsyncTreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>>(PrepareAsyncTreeQueryRaw(context, request, cq));
    }
    ::grpc::Status BansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::MurmurRPC::Ban_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>> AsyncBansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>>(AsyncBansGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>> PrepareAsyncBansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>>(PrepareAsyncBansGetRaw(context, request, cq));
    }
    ::grpc::Status BansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncBansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncBansSetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncBansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncBansSetRaw(context, request, cq));
    }
    ::grpc::Status ACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::MurmurRPC::ACL_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>> AsyncACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>>(AsyncACLGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>> PrepareAsyncACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>>(PrepareAsyncACLGetRaw(context, request, cq));
    }
    ::grpc::Status ACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncACLSetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncACLSetRaw(context, request, cq));
    }
    ::grpc::Status ACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::MurmurRPC::ACL* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>> AsyncACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>>(AsyncACLGetEffectivePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>> PrepareAsyncACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>>(PrepareAsyncACLGetEffectivePermissionsRaw(context, request, cq));
    }
    ::grpc::Status ACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncACLAddTemporaryGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncACLAddTemporaryGroupRaw(context, request, cq));
    }
    ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncACLRemoveTemporaryGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncACLRemoveTemporaryGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> AuthenticatorStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(AuthenticatorStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> AsyncAuthenticatorStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(AsyncAuthenticatorStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>> PrepareAsyncAuthenticatorStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>>(PrepareAsyncAuthenticatorStreamRaw(context, cq));
    }
    ::grpc::Status DatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::MurmurRPC::DatabaseUser_List* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>> AsyncDatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>>(AsyncDatabaseUserQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>> PrepareAsyncDatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>>(PrepareAsyncDatabaseUserQueryRaw(context, request, cq));
    }
    ::grpc::Status DatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::DatabaseUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserGetRaw(context, request, cq));
    }
    ::grpc::Status DatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncDatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncDatabaseUserUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncDatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncDatabaseUserUpdateRaw(context, request, cq));
    }
    ::grpc::Status DatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::DatabaseUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserRegisterRaw(context, request, cq));
    }
    ::grpc::Status DatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncDatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncDatabaseUserDeregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncDatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncDatabaseUserDeregisterRaw(context, request, cq));
    }
    ::grpc::Status DatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::MurmurRPC::DatabaseUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> AsyncDatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(AsyncDatabaseUserVerifyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>> PrepareAsyncDatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>>(PrepareAsyncDatabaseUserVerifyRaw(context, request, cq));
    }
    ::grpc::Status RedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncRedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncRedirectWhisperGroupAddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncRedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncRedirectWhisperGroupAddRaw(context, request, cq));
    }
    ::grpc::Status RedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::MurmurRPC::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> AsyncRedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(AsyncRedirectWhisperGroupRemoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>> PrepareAsyncRedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>>(PrepareAsyncRedirectWhisperGroupRemoveRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetUptime(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response, std::function<void(::grpc::Status)>) override;
      void ServerCreate(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response, std::function<void(::grpc::Status)>) override;
      void ServerQuery(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response, std::function<void(::grpc::Status)>) override;
      void ServerGet(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response, std::function<void(::grpc::Status)>) override;
      void ServerStart(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ServerStop(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ServerRemove(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ContextActionAdd(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ContextActionRemove(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void TextMessageSend(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void LogQuery(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response, std::function<void(::grpc::Status)>) override;
      void ConfigGet(::grpc::ClientContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response, std::function<void(::grpc::Status)>) override;
      void ConfigGetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response, std::function<void(::grpc::Status)>) override;
      void ConfigSetField(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ConfigGetDefault(::grpc::ClientContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response, std::function<void(::grpc::Status)>) override;
      void ChannelQuery(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response, std::function<void(::grpc::Status)>) override;
      void ChannelGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) override;
      void ChannelAdd(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) override;
      void ChannelRemove(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ChannelUpdate(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response, std::function<void(::grpc::Status)>) override;
      void UserQuery(::grpc::ClientContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response, std::function<void(::grpc::Status)>) override;
      void UserGet(::grpc::ClientContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response, std::function<void(::grpc::Status)>) override;
      void UserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response, std::function<void(::grpc::Status)>) override;
      void UserKick(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void TreeQuery(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response, std::function<void(::grpc::Status)>) override;
      void BansGet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response, std::function<void(::grpc::Status)>) override;
      void BansSet(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ACLGet(::grpc::ClientContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response, std::function<void(::grpc::Status)>) override;
      void ACLSet(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ACLGetEffectivePermissions(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response, std::function<void(::grpc::Status)>) override;
      void ACLAddTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void ACLRemoveTemporaryGroup(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserQuery(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserGet(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserUpdate(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserRegister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserDeregister(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void DatabaseUserVerify(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response, std::function<void(::grpc::Status)>) override;
      void RedirectWhisperGroupAdd(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
      void RedirectWhisperGroupRemove(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>* AsyncGetUptimeRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Uptime>* PrepareAsyncGetUptimeRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Version>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::MurmurRPC::Event>* EventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::Event>* AsyncEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::Event>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>* AsyncServerCreateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>* PrepareAsyncServerCreateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>* AsyncServerQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server_List>* PrepareAsyncServerQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>* AsyncServerGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Server>* PrepareAsyncServerGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncServerStartRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncServerStartRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncServerStopRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncServerStopRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncServerRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncServerRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::MurmurRPC::Server_Event>* ServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>* AsyncServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::Server_Event>* PrepareAsyncServerEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncContextActionAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncContextActionAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncContextActionRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncContextActionRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::MurmurRPC::ContextAction>* ContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>* AsyncContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::MurmurRPC::ContextAction>* PrepareAsyncContextActionEventsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ContextAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncTextMessageSendRaw(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncTextMessageSendRaw(::grpc::ClientContext* context, const ::MurmurRPC::TextMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* TextMessageFilterRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* AsyncTextMessageFilterRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* PrepareAsyncTextMessageFilterRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>* AsyncLogQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Log_List>* PrepareAsyncLogQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Log_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>* AsyncConfigGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>* PrepareAsyncConfigGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Server& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>* AsyncConfigGetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config_Field>* PrepareAsyncConfigGetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncConfigSetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncConfigSetFieldRaw(::grpc::ClientContext* context, const ::MurmurRPC::Config_Field& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>* AsyncConfigGetDefaultRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Config>* PrepareAsyncConfigGetDefaultRaw(::grpc::ClientContext* context, const ::MurmurRPC::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>* AsyncChannelQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel_List>* PrepareAsyncChannelQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* AsyncChannelGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* PrepareAsyncChannelGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* AsyncChannelAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* PrepareAsyncChannelAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncChannelRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncChannelRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* AsyncChannelUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Channel>* PrepareAsyncChannelUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>* AsyncUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User_List>* PrepareAsyncUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>* AsyncUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>* PrepareAsyncUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>* AsyncUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::User>* PrepareAsyncUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::User& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncUserKickRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncUserKickRaw(::grpc::ClientContext* context, const ::MurmurRPC::User_Kick& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>* AsyncTreeQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Tree>* PrepareAsyncTreeQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::Tree_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>* AsyncBansGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Ban_List>* PrepareAsyncBansGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncBansSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncBansSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Ban_List& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>* AsyncACLGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL_List>* PrepareAsyncACLGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::Channel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncACLSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncACLSetRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_List& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>* AsyncACLGetEffectivePermissionsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::ACL>* PrepareAsyncACLGetEffectivePermissionsRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncACLAddTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncACLAddTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncACLRemoveTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncACLRemoveTemporaryGroupRaw(::grpc::ClientContext* context, const ::MurmurRPC::ACL_TemporaryGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* AuthenticatorStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* AsyncAuthenticatorStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request>* PrepareAsyncAuthenticatorStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>* AsyncDatabaseUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser_List>* PrepareAsyncDatabaseUserQueryRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserGetRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncDatabaseUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncDatabaseUserUpdateRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserRegisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserRegisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncDatabaseUserDeregisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncDatabaseUserDeregisterRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* AsyncDatabaseUserVerifyRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::DatabaseUser>* PrepareAsyncDatabaseUserVerifyRaw(::grpc::ClientContext* context, const ::MurmurRPC::DatabaseUser_Verify& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncRedirectWhisperGroupAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncRedirectWhisperGroupAddRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* AsyncRedirectWhisperGroupRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MurmurRPC::Void>* PrepareAsyncRedirectWhisperGroupRemoveRaw(::grpc::ClientContext* context, const ::MurmurRPC::RedirectWhisperGroup& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetUptime_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_Events_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerCreate_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerGet_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerStart_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerStop_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerRemove_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_ContextActionAdd_;
    const ::grpc::internal::RpcMethod rpcmethod_ContextActionRemove_;
    const ::grpc::internal::RpcMethod rpcmethod_ContextActionEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_TextMessageSend_;
    const ::grpc::internal::RpcMethod rpcmethod_TextMessageFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_LogQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigGet_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigGetField_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigSetField_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigGetDefault_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelGet_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelAdd_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelRemove_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_UserQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_UserGet_;
    const ::grpc::internal::RpcMethod rpcmethod_UserUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_UserKick_;
    const ::grpc::internal::RpcMethod rpcmethod_TreeQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_BansGet_;
    const ::grpc::internal::RpcMethod rpcmethod_BansSet_;
    const ::grpc::internal::RpcMethod rpcmethod_ACLGet_;
    const ::grpc::internal::RpcMethod rpcmethod_ACLSet_;
    const ::grpc::internal::RpcMethod rpcmethod_ACLGetEffectivePermissions_;
    const ::grpc::internal::RpcMethod rpcmethod_ACLAddTemporaryGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_ACLRemoveTemporaryGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticatorStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserQuery_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserGet_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserRegister_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserDeregister_;
    const ::grpc::internal::RpcMethod rpcmethod_DatabaseUserVerify_;
    const ::grpc::internal::RpcMethod rpcmethod_RedirectWhisperGroupAdd_;
    const ::grpc::internal::RpcMethod rpcmethod_RedirectWhisperGroupRemove_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GetUptime returns murmur's uptime.
    virtual ::grpc::Status GetUptime(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response);
    // GetVersion returns murmur's version.
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response);
    // Events returns a stream of murmur events.
    virtual ::grpc::Status Events(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::grpc::ServerWriter< ::MurmurRPC::Event>* writer);
    //
    // Servers
    //
    //
    // ServerCreate creates a new virtual server. The returned server object
    // contains the newly created server's ID.
    virtual ::grpc::Status ServerCreate(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response);
    // ServerQuery returns a list of servers that match the given query.
    virtual ::grpc::Status ServerQuery(::grpc::ServerContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response);
    // ServerGet returns information about the given server.
    virtual ::grpc::Status ServerGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response);
    // ServerStart starts the given stopped server.
    virtual ::grpc::Status ServerStart(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response);
    // ServerStop stops the given virtual server.
    virtual ::grpc::Status ServerStop(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response);
    // ServerRemove removes the given virtual server and its configuration.
    virtual ::grpc::Status ServerRemove(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response);
    // ServerEvents returns a stream of events that happen on the given server.
    virtual ::grpc::Status ServerEvents(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::grpc::ServerWriter< ::MurmurRPC::Server_Event>* writer);
    //
    // ContextActions
    //
    //
    // ContextActionAdd adds a context action to the given user's client. The
    // following ContextAction fields must be set:
    //   context, action, text, and user.
    //
    // Added context actions are valid until:
    //  - The context action is removed with ContextActionRemove, or
    //  - The user disconnects from the server, or
    //  - The server stops.
    virtual ::grpc::Status ContextActionAdd(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response);
    // ContextActionRemove removes a context action from the given user's client.
    // The following ContextAction must be set:
    //   action
    // If no user is given, the context action is removed from all users.
    virtual ::grpc::Status ContextActionRemove(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response);
    // ContextActionEvents returns a stream of context action events that are
    // triggered by users.
    virtual ::grpc::Status ContextActionEvents(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::grpc::ServerWriter< ::MurmurRPC::ContextAction>* writer);
    //
    // TextMessage
    //
    //
    // TextMessageSend sends the given TextMessage to the server.
    //
    // If no users, channels, or trees are added to the TextMessage, the message
    // will be broadcast the entire server. Otherwise, the message will be
    // targeted to the specified users, channels, and trees.
    virtual ::grpc::Status TextMessageSend(::grpc::ServerContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response);
    // TextMessageFilter filters text messages on a given server.
    // TextMessageFilter filters text messages for a given server.
    //
    // When a filter stream is active, text messages sent from users to the
    // server are sent over the stream. The RPC client then sends a message back
    // on the same stream, containing an action: whether the message should be
    // accepted, rejected, or dropped.
    //
    // To activate the filter stream, an initial TextMessage.Filter message must
    // be sent that contains the server on which the filter will be active.
    virtual ::grpc::Status TextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* stream);
    //
    // Logs
    //
    //
    // LogQuery returns a list of log entries from the given server.
    //
    // To get the total number of log entries, omit min and/or max from the
    // query.
    virtual ::grpc::Status LogQuery(::grpc::ServerContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response);
    //
    // Config
    //
    //
    // ConfigGet returns the explicitly set configuration for the given server.
    virtual ::grpc::Status ConfigGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response);
    // ConfigGetField returns the configuration value for the given key.
    virtual ::grpc::Status ConfigGetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response);
    // ConfigSetField sets the configuration value to the given value.
    virtual ::grpc::Status ConfigSetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response);
    // ConfigGetDefault returns the default server configuration.
    virtual ::grpc::Status ConfigGetDefault(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response);
    //
    // Channels
    //
    //
    // ChannelQuery returns a list of channels that match the given query.
    virtual ::grpc::Status ChannelQuery(::grpc::ServerContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response);
    // ChannelGet returns the channel with the given ID.
    virtual ::grpc::Status ChannelGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response);
    // ChannelAdd adds the channel to the given server. The parent and name of
    // the channel must be set.
    virtual ::grpc::Status ChannelAdd(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response);
    // ChannelRemove removes the given channel from the server.
    virtual ::grpc::Status ChannelRemove(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response);
    // ChannelUpdate updates the given channel's attributes. Only the fields that
    // are set will be updated.
    virtual ::grpc::Status ChannelUpdate(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response);
    //
    // Users
    //
    //
    // UserQuery returns a list of connected users who match the given query.
    virtual ::grpc::Status UserQuery(::grpc::ServerContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response);
    // UserGet returns information on the connected user, given by the user's
    // session or name.
    virtual ::grpc::Status UserGet(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response);
    // UserUpdate changes the given user's state. Only the following fields can
    // be changed:
    //   name, mute, deaf, suppress, priority_speaker, channel, comment.
    virtual ::grpc::Status UserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response);
    // UserKick kicks the user from the server.
    virtual ::grpc::Status UserKick(::grpc::ServerContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response);
    //
    // Tree
    //
    //
    // TreeQuery returns a representation of the given server's channel/user
    // tree.
    virtual ::grpc::Status TreeQuery(::grpc::ServerContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response);
    //
    // Bans
    //
    //
    // BansGet returns a list of bans for the given server.
    virtual ::grpc::Status BansGet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response);
    // BansSet replaces the server's ban list with the given list.
    virtual ::grpc::Status BansSet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response);
    //
    // ACL
    //
    //
    // ACLGet returns the ACL for the given channel.
    virtual ::grpc::Status ACLGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response);
    // ACLSet overrides the ACL of the given channel to what is provided.
    virtual ::grpc::Status ACLSet(::grpc::ServerContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response);
    // ACLGetEffectivePermissions returns the effective permissions for the given
    // user in the given channel.
    virtual ::grpc::Status ACLGetEffectivePermissions(::grpc::ServerContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response);
    // ACLAddTemporaryGroup adds a user to a temporary group.
    virtual ::grpc::Status ACLAddTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response);
    // ACLRemoveTemporaryGroup removes a user from a temporary group.
    virtual ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response);
    //
    // Authenticator
    //
    //
    // AuthenticatorStream opens an authentication stream to the server.
    //
    // There can only be one RPC client with an open Stream. If a new
    // authenticator connects, the open connected will be closed.
    virtual ::grpc::Status AuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response>* stream);
    //
    // Database
    //
    //
    // DatabaseUserQuery returns a list of registered users who match given
    // query.
    virtual ::grpc::Status DatabaseUserQuery(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response);
    // DatabaseUserGet returns the database user with the given ID.
    virtual ::grpc::Status DatabaseUserGet(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response);
    // DatabaseUserUpdate updates the given database user.
    virtual ::grpc::Status DatabaseUserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response);
    // DatabaseUserRegister registers a user with the given information on the
    // server. The returned DatabaseUser will contain the newly registered user's
    // ID.
    virtual ::grpc::Status DatabaseUserRegister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response);
    // DatabaseUserDeregister deregisters the given user.
    virtual ::grpc::Status DatabaseUserDeregister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response);
    // DatabaseUserVerify verifies the that the given user-password pair is
    // correct.
    virtual ::grpc::Status DatabaseUserVerify(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response);
    //
    // Audio
    //
    //
    // AddRedirectWhisperGroup add a whisper targets redirection for the given
    // user. Whenever a user whispers to group "source", the whisper will be
    // redirected to group "target".
    virtual ::grpc::Status RedirectWhisperGroupAdd(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response);
    // RemoveRedirectWhisperGroup removes a whisper target redirection for
    // the the given user.
    virtual ::grpc::Status RedirectWhisperGroupRemove(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetUptime() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetUptime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUptime(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUptime(::grpc::ServerContext* context, ::MurmurRPC::Void* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Uptime>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::MurmurRPC::Void* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Version>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Events() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::grpc::ServerWriter< ::MurmurRPC::Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::MurmurRPC::Void* request, ::grpc::ServerAsyncWriter< ::MurmurRPC::Event>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerCreate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerCreate() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ServerCreate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerCreate(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerCreate(::grpc::ServerContext* context, ::MurmurRPC::Void* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerQuery() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ServerQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerQuery(::grpc::ServerContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerQuery(::grpc::ServerContext* context, ::MurmurRPC::Server_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerGet() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ServerGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerGet(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerStart() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ServerStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStart(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerStart(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerStop() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ServerStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStop(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerStop(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerRemove() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ServerRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerRemove(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerRemove(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerEvents() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ServerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerEvents(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::grpc::ServerWriter< ::MurmurRPC::Server_Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerEvents(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncWriter< ::MurmurRPC::Server_Event>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContextActionAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ContextActionAdd() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ContextActionAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionAdd(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionAdd(::grpc::ServerContext* context, ::MurmurRPC::ContextAction* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContextActionRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ContextActionRemove() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ContextActionRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionRemove(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionRemove(::grpc::ServerContext* context, ::MurmurRPC::ContextAction* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContextActionEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ContextActionEvents() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ContextActionEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionEvents(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::grpc::ServerWriter< ::MurmurRPC::ContextAction>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionEvents(::grpc::ServerContext* context, ::MurmurRPC::ContextAction* request, ::grpc::ServerAsyncWriter< ::MurmurRPC::ContextAction>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TextMessageSend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TextMessageSend() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_TextMessageSend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageSend(::grpc::ServerContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextMessageSend(::grpc::ServerContext* context, ::MurmurRPC::TextMessage* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TextMessageFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TextMessageFilter() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_TextMessageFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(14, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LogQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LogQuery() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_LogQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogQuery(::grpc::ServerContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogQuery(::grpc::ServerContext* context, ::MurmurRPC::Log_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Log_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ConfigGet() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_ConfigGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGet(::grpc::ServerContext* context, ::MurmurRPC::Server* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Config>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigGetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ConfigGetField() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ConfigGetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGetField(::grpc::ServerContext* context, ::MurmurRPC::Config_Field* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Config_Field>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigSetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ConfigSetField() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ConfigSetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigSetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigSetField(::grpc::ServerContext* context, ::MurmurRPC::Config_Field* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigGetDefault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ConfigGetDefault() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_ConfigGetDefault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetDefault(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGetDefault(::grpc::ServerContext* context, ::MurmurRPC::Void* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Config>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ChannelQuery() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_ChannelQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelQuery(::grpc::ServerContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelQuery(::grpc::ServerContext* context, ::MurmurRPC::Channel_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ChannelGet() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_ChannelGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelGet(::grpc::ServerContext* context, ::MurmurRPC::Channel* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ChannelAdd() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_ChannelAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAdd(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelAdd(::grpc::ServerContext* context, ::MurmurRPC::Channel* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ChannelRemove() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_ChannelRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelRemove(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelRemove(::grpc::ServerContext* context, ::MurmurRPC::Channel* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ChannelUpdate() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ChannelUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelUpdate(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelUpdate(::grpc::ServerContext* context, ::MurmurRPC::Channel* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UserQuery() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_UserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserQuery(::grpc::ServerContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserQuery(::grpc::ServerContext* context, ::MurmurRPC::User_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UserGet() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_UserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserGet(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserGet(::grpc::ServerContext* context, ::MurmurRPC::User* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UserUpdate() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_UserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserUpdate(::grpc::ServerContext* context, ::MurmurRPC::User* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserKick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UserKick() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_UserKick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserKick(::grpc::ServerContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserKick(::grpc::ServerContext* context, ::MurmurRPC::User_Kick* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TreeQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TreeQuery() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_TreeQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TreeQuery(::grpc::ServerContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTreeQuery(::grpc::ServerContext* context, ::MurmurRPC::Tree_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Tree>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BansGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_BansGet() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_BansGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansGet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBansGet(::grpc::ServerContext* context, ::MurmurRPC::Ban_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Ban_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BansSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_BansSet() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_BansSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansSet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBansSet(::grpc::ServerContext* context, ::MurmurRPC::Ban_List* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ACLGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ACLGet() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ACLGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLGet(::grpc::ServerContext* context, ::MurmurRPC::Channel* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::ACL_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ACLSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ACLSet() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_ACLSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLSet(::grpc::ServerContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLSet(::grpc::ServerContext* context, ::MurmurRPC::ACL_List* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ACLGetEffectivePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ACLGetEffectivePermissions() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_ACLGetEffectivePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGetEffectivePermissions(::grpc::ServerContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLGetEffectivePermissions(::grpc::ServerContext* context, ::MurmurRPC::ACL_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::ACL>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ACLAddTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ACLAddTemporaryGroup() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_ACLAddTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLAddTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLAddTemporaryGroup(::grpc::ServerContext* context, ::MurmurRPC::ACL_TemporaryGroup* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ACLRemoveTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ACLRemoveTemporaryGroup() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_ACLRemoveTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLRemoveTemporaryGroup(::grpc::ServerContext* context, ::MurmurRPC::ACL_TemporaryGroup* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticatorStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_AuthenticatorStream() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_AuthenticatorStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(37, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserQuery() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_DatabaseUserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserQuery(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserQuery(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser_Query* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser_List>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserGet() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_DatabaseUserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserGet(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserGet(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserUpdate() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_DatabaseUserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserUpdate(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserRegister() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_DatabaseUserRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserRegister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserRegister(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserDeregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserDeregister() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_DatabaseUserDeregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserDeregister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserDeregister(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatabaseUserVerify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatabaseUserVerify() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_DatabaseUserVerify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserVerify(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserVerify(::grpc::ServerContext* context, ::MurmurRPC::DatabaseUser_Verify* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RedirectWhisperGroupAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RedirectWhisperGroupAdd() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_RedirectWhisperGroupAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupAdd(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRedirectWhisperGroupAdd(::grpc::ServerContext* context, ::MurmurRPC::RedirectWhisperGroup* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RedirectWhisperGroupRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RedirectWhisperGroupRemove() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_RedirectWhisperGroupRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupRemove(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRedirectWhisperGroupRemove(::grpc::ServerContext* context, ::MurmurRPC::RedirectWhisperGroup* request, ::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetUptime<WithAsyncMethod_GetVersion<WithAsyncMethod_Events<WithAsyncMethod_ServerCreate<WithAsyncMethod_ServerQuery<WithAsyncMethod_ServerGet<WithAsyncMethod_ServerStart<WithAsyncMethod_ServerStop<WithAsyncMethod_ServerRemove<WithAsyncMethod_ServerEvents<WithAsyncMethod_ContextActionAdd<WithAsyncMethod_ContextActionRemove<WithAsyncMethod_ContextActionEvents<WithAsyncMethod_TextMessageSend<WithAsyncMethod_TextMessageFilter<WithAsyncMethod_LogQuery<WithAsyncMethod_ConfigGet<WithAsyncMethod_ConfigGetField<WithAsyncMethod_ConfigSetField<WithAsyncMethod_ConfigGetDefault<WithAsyncMethod_ChannelQuery<WithAsyncMethod_ChannelGet<WithAsyncMethod_ChannelAdd<WithAsyncMethod_ChannelRemove<WithAsyncMethod_ChannelUpdate<WithAsyncMethod_UserQuery<WithAsyncMethod_UserGet<WithAsyncMethod_UserUpdate<WithAsyncMethod_UserKick<WithAsyncMethod_TreeQuery<WithAsyncMethod_BansGet<WithAsyncMethod_BansSet<WithAsyncMethod_ACLGet<WithAsyncMethod_ACLSet<WithAsyncMethod_ACLGetEffectivePermissions<WithAsyncMethod_ACLAddTemporaryGroup<WithAsyncMethod_ACLRemoveTemporaryGroup<WithAsyncMethod_AuthenticatorStream<WithAsyncMethod_DatabaseUserQuery<WithAsyncMethod_DatabaseUserGet<WithAsyncMethod_DatabaseUserUpdate<WithAsyncMethod_DatabaseUserRegister<WithAsyncMethod_DatabaseUserDeregister<WithAsyncMethod_DatabaseUserVerify<WithAsyncMethod_RedirectWhisperGroupAdd<WithAsyncMethod_RedirectWhisperGroupRemove<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_GetUptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetUptime() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetUptime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUptime(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Events() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::grpc::ServerWriter< ::MurmurRPC::Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerCreate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerCreate() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ServerCreate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerCreate(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerQuery() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ServerQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerQuery(::grpc::ServerContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerGet() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ServerGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerStart() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ServerStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStart(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerStop() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ServerStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStop(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerRemove() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ServerRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerRemove(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerEvents() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ServerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerEvents(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::grpc::ServerWriter< ::MurmurRPC::Server_Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContextActionAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ContextActionAdd() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ContextActionAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionAdd(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContextActionRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ContextActionRemove() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ContextActionRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionRemove(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContextActionEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ContextActionEvents() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ContextActionEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionEvents(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::grpc::ServerWriter< ::MurmurRPC::ContextAction>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TextMessageSend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TextMessageSend() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_TextMessageSend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageSend(::grpc::ServerContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TextMessageFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TextMessageFilter() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_TextMessageFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LogQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LogQuery() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_LogQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogQuery(::grpc::ServerContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ConfigGet() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_ConfigGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigGetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ConfigGetField() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ConfigGetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigSetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ConfigSetField() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ConfigSetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigSetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigGetDefault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ConfigGetDefault() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_ConfigGetDefault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetDefault(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ChannelQuery() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_ChannelQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelQuery(::grpc::ServerContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ChannelGet() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_ChannelGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ChannelAdd() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_ChannelAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAdd(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ChannelRemove() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_ChannelRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelRemove(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ChannelUpdate() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ChannelUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelUpdate(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UserQuery() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_UserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserQuery(::grpc::ServerContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UserGet() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_UserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserGet(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UserUpdate() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_UserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserKick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UserKick() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_UserKick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserKick(::grpc::ServerContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TreeQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TreeQuery() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_TreeQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TreeQuery(::grpc::ServerContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BansGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_BansGet() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_BansGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansGet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BansSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_BansSet() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_BansSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansSet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ACLGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ACLGet() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ACLGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ACLSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ACLSet() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_ACLSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLSet(::grpc::ServerContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ACLGetEffectivePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ACLGetEffectivePermissions() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_ACLGetEffectivePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGetEffectivePermissions(::grpc::ServerContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ACLAddTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ACLAddTemporaryGroup() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_ACLAddTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLAddTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ACLRemoveTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ACLRemoveTemporaryGroup() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_ACLRemoveTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticatorStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_AuthenticatorStream() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_AuthenticatorStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserQuery() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_DatabaseUserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserQuery(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserGet() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_DatabaseUserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserGet(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserUpdate() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_DatabaseUserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserRegister() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_DatabaseUserRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserRegister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserDeregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserDeregister() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_DatabaseUserDeregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserDeregister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatabaseUserVerify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatabaseUserVerify() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_DatabaseUserVerify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserVerify(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RedirectWhisperGroupAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RedirectWhisperGroupAdd() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_RedirectWhisperGroupAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupAdd(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RedirectWhisperGroupRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RedirectWhisperGroupRemove() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_RedirectWhisperGroupRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupRemove(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetUptime() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetUptime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUptime(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUptime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Events() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::grpc::ServerWriter< ::MurmurRPC::Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerCreate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerCreate() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ServerCreate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerCreate(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerCreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerQuery() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ServerQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerQuery(::grpc::ServerContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerGet() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ServerGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerStart() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ServerStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStart(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerStop() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ServerStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerStop(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerRemove() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ServerRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerRemove(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerRemove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ServerEvents() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ServerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerEvents(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::grpc::ServerWriter< ::MurmurRPC::Server_Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContextActionAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ContextActionAdd() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ContextActionAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionAdd(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionAdd(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContextActionRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ContextActionRemove() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ContextActionRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionRemove(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionRemove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContextActionEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ContextActionEvents() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ContextActionEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContextActionEvents(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::grpc::ServerWriter< ::MurmurRPC::ContextAction>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContextActionEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TextMessageSend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TextMessageSend() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_TextMessageSend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageSend(::grpc::ServerContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextMessageSend(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TextMessageFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TextMessageFilter() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_TextMessageFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextMessageFilter(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(14, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LogQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_LogQuery() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_LogQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogQuery(::grpc::ServerContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ConfigGet() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_ConfigGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigGetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ConfigGetField() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ConfigGetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGetField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigSetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ConfigSetField() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ConfigSetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigSetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigSetField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigGetDefault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ConfigGetDefault() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_ConfigGetDefault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigGetDefault(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigGetDefault(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ChannelQuery() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_ChannelQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelQuery(::grpc::ServerContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ChannelGet() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_ChannelGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ChannelAdd() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_ChannelAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelAdd(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelAdd(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ChannelRemove() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_ChannelRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelRemove(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelRemove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ChannelUpdate() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ChannelUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelUpdate(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UserQuery() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_UserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserQuery(::grpc::ServerContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UserGet() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_UserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserGet(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UserUpdate() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_UserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserKick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UserKick() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_UserKick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserKick(::grpc::ServerContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserKick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TreeQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TreeQuery() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_TreeQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TreeQuery(::grpc::ServerContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTreeQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BansGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_BansGet() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_BansGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansGet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBansGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BansSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_BansSet() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_BansSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BansSet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBansSet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ACLGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ACLGet() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ACLGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ACLSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ACLSet() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_ACLSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLSet(::grpc::ServerContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLSet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ACLGetEffectivePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ACLGetEffectivePermissions() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_ACLGetEffectivePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLGetEffectivePermissions(::grpc::ServerContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLGetEffectivePermissions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ACLAddTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ACLAddTemporaryGroup() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_ACLAddTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLAddTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLAddTemporaryGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ACLRemoveTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ACLRemoveTemporaryGroup() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_ACLRemoveTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestACLRemoveTemporaryGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticatorStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_AuthenticatorStream() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_AuthenticatorStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticatorStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(37, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserQuery() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_DatabaseUserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserQuery(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserGet() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_DatabaseUserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserGet(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserUpdate() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_DatabaseUserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserRegister() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_DatabaseUserRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserRegister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserDeregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserDeregister() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_DatabaseUserDeregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserDeregister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserDeregister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DatabaseUserVerify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DatabaseUserVerify() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_DatabaseUserVerify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatabaseUserVerify(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatabaseUserVerify(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RedirectWhisperGroupAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RedirectWhisperGroupAdd() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_RedirectWhisperGroupAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupAdd(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRedirectWhisperGroupAdd(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RedirectWhisperGroupRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RedirectWhisperGroupRemove() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_RedirectWhisperGroupRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RedirectWhisperGroupRemove(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRedirectWhisperGroupRemove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUptime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetUptime() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Void, ::MurmurRPC::Uptime>(std::bind(&WithStreamedUnaryMethod_GetUptime<BaseClass>::StreamedGetUptime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetUptime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUptime(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Uptime* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUptime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Void,::MurmurRPC::Uptime>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Void, ::MurmurRPC::Version>(std::bind(&WithStreamedUnaryMethod_GetVersion<BaseClass>::StreamedGetVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Version* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Void,::MurmurRPC::Version>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerCreate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerCreate() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Void, ::MurmurRPC::Server>(std::bind(&WithStreamedUnaryMethod_ServerCreate<BaseClass>::StreamedServerCreate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerCreate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerCreate(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerCreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Void,::MurmurRPC::Server>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerQuery() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server_Query, ::MurmurRPC::Server_List>(std::bind(&WithStreamedUnaryMethod_ServerQuery<BaseClass>::StreamedServerQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerQuery(::grpc::ServerContext* context, const ::MurmurRPC::Server_Query* request, ::MurmurRPC::Server_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server_Query,::MurmurRPC::Server_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerGet() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server, ::MurmurRPC::Server>(std::bind(&WithStreamedUnaryMethod_ServerGet<BaseClass>::StreamedServerGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Server* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server,::MurmurRPC::Server>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerStart() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ServerStart<BaseClass>::StreamedServerStart, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerStart(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerStop() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ServerStop<BaseClass>::StreamedServerStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerStop(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerRemove() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ServerRemove<BaseClass>::StreamedServerRemove, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerRemove(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerRemove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContextActionAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ContextActionAdd() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ContextAction, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ContextActionAdd<BaseClass>::StreamedContextActionAdd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ContextActionAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContextActionAdd(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContextActionAdd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ContextAction,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContextActionRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ContextActionRemove() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ContextAction, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ContextActionRemove<BaseClass>::StreamedContextActionRemove, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ContextActionRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContextActionRemove(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContextActionRemove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ContextAction,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TextMessageSend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TextMessageSend() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::TextMessage, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_TextMessageSend<BaseClass>::StreamedTextMessageSend, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TextMessageSend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TextMessageSend(::grpc::ServerContext* context, const ::MurmurRPC::TextMessage* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTextMessageSend(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::TextMessage,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LogQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_LogQuery() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Log_Query, ::MurmurRPC::Log_List>(std::bind(&WithStreamedUnaryMethod_LogQuery<BaseClass>::StreamedLogQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LogQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LogQuery(::grpc::ServerContext* context, const ::MurmurRPC::Log_Query* request, ::MurmurRPC::Log_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Log_Query,::MurmurRPC::Log_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ConfigGet() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Server, ::MurmurRPC::Config>(std::bind(&WithStreamedUnaryMethod_ConfigGet<BaseClass>::StreamedConfigGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ConfigGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigGet(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Server,::MurmurRPC::Config>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigGetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ConfigGetField() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Config_Field, ::MurmurRPC::Config_Field>(std::bind(&WithStreamedUnaryMethod_ConfigGetField<BaseClass>::StreamedConfigGetField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ConfigGetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigGetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Config_Field* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigGetField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Config_Field,::MurmurRPC::Config_Field>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigSetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ConfigSetField() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Config_Field, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ConfigSetField<BaseClass>::StreamedConfigSetField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ConfigSetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigSetField(::grpc::ServerContext* context, const ::MurmurRPC::Config_Field* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigSetField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Config_Field,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigGetDefault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ConfigGetDefault() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Void, ::MurmurRPC::Config>(std::bind(&WithStreamedUnaryMethod_ConfigGetDefault<BaseClass>::StreamedConfigGetDefault, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ConfigGetDefault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigGetDefault(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::MurmurRPC::Config* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigGetDefault(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Void,::MurmurRPC::Config>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ChannelQuery() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel_Query, ::MurmurRPC::Channel_List>(std::bind(&WithStreamedUnaryMethod_ChannelQuery<BaseClass>::StreamedChannelQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelQuery(::grpc::ServerContext* context, const ::MurmurRPC::Channel_Query* request, ::MurmurRPC::Channel_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel_Query,::MurmurRPC::Channel_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ChannelGet() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel, ::MurmurRPC::Channel>(std::bind(&WithStreamedUnaryMethod_ChannelGet<BaseClass>::StreamedChannelGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel,::MurmurRPC::Channel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ChannelAdd() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel, ::MurmurRPC::Channel>(std::bind(&WithStreamedUnaryMethod_ChannelAdd<BaseClass>::StreamedChannelAdd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelAdd(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelAdd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel,::MurmurRPC::Channel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ChannelRemove() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ChannelRemove<BaseClass>::StreamedChannelRemove, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelRemove(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelRemove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ChannelUpdate() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel, ::MurmurRPC::Channel>(std::bind(&WithStreamedUnaryMethod_ChannelUpdate<BaseClass>::StreamedChannelUpdate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChannelUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelUpdate(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::Channel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel,::MurmurRPC::Channel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UserQuery() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::User_Query, ::MurmurRPC::User_List>(std::bind(&WithStreamedUnaryMethod_UserQuery<BaseClass>::StreamedUserQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserQuery(::grpc::ServerContext* context, const ::MurmurRPC::User_Query* request, ::MurmurRPC::User_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::User_Query,::MurmurRPC::User_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UserGet() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::User, ::MurmurRPC::User>(std::bind(&WithStreamedUnaryMethod_UserGet<BaseClass>::StreamedUserGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserGet(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::User,::MurmurRPC::User>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UserUpdate() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::User, ::MurmurRPC::User>(std::bind(&WithStreamedUnaryMethod_UserUpdate<BaseClass>::StreamedUserUpdate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::User* request, ::MurmurRPC::User* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::User,::MurmurRPC::User>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserKick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UserKick() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::User_Kick, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_UserKick<BaseClass>::StreamedUserKick, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UserKick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserKick(::grpc::ServerContext* context, const ::MurmurRPC::User_Kick* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserKick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::User_Kick,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TreeQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TreeQuery() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Tree_Query, ::MurmurRPC::Tree>(std::bind(&WithStreamedUnaryMethod_TreeQuery<BaseClass>::StreamedTreeQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TreeQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TreeQuery(::grpc::ServerContext* context, const ::MurmurRPC::Tree_Query* request, ::MurmurRPC::Tree* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTreeQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Tree_Query,::MurmurRPC::Tree>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BansGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_BansGet() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Ban_Query, ::MurmurRPC::Ban_List>(std::bind(&WithStreamedUnaryMethod_BansGet<BaseClass>::StreamedBansGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BansGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BansGet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_Query* request, ::MurmurRPC::Ban_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBansGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Ban_Query,::MurmurRPC::Ban_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BansSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_BansSet() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Ban_List, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_BansSet<BaseClass>::StreamedBansSet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BansSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BansSet(::grpc::ServerContext* context, const ::MurmurRPC::Ban_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBansSet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Ban_List,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ACLGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ACLGet() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::Channel, ::MurmurRPC::ACL_List>(std::bind(&WithStreamedUnaryMethod_ACLGet<BaseClass>::StreamedACLGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ACLGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ACLGet(::grpc::ServerContext* context, const ::MurmurRPC::Channel* request, ::MurmurRPC::ACL_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedACLGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::Channel,::MurmurRPC::ACL_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ACLSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ACLSet() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ACL_List, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ACLSet<BaseClass>::StreamedACLSet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ACLSet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ACLSet(::grpc::ServerContext* context, const ::MurmurRPC::ACL_List* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedACLSet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ACL_List,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ACLGetEffectivePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ACLGetEffectivePermissions() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ACL_Query, ::MurmurRPC::ACL>(std::bind(&WithStreamedUnaryMethod_ACLGetEffectivePermissions<BaseClass>::StreamedACLGetEffectivePermissions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ACLGetEffectivePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ACLGetEffectivePermissions(::grpc::ServerContext* context, const ::MurmurRPC::ACL_Query* request, ::MurmurRPC::ACL* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedACLGetEffectivePermissions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ACL_Query,::MurmurRPC::ACL>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ACLAddTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ACLAddTemporaryGroup() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ACL_TemporaryGroup, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ACLAddTemporaryGroup<BaseClass>::StreamedACLAddTemporaryGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ACLAddTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ACLAddTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedACLAddTemporaryGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ACL_TemporaryGroup,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ACLRemoveTemporaryGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ACLRemoveTemporaryGroup() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::ACL_TemporaryGroup, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_ACLRemoveTemporaryGroup<BaseClass>::StreamedACLRemoveTemporaryGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ACLRemoveTemporaryGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ACLRemoveTemporaryGroup(::grpc::ServerContext* context, const ::MurmurRPC::ACL_TemporaryGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedACLRemoveTemporaryGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::ACL_TemporaryGroup,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserQuery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserQuery() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser_Query, ::MurmurRPC::DatabaseUser_List>(std::bind(&WithStreamedUnaryMethod_DatabaseUserQuery<BaseClass>::StreamedDatabaseUserQuery, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserQuery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserQuery(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Query* request, ::MurmurRPC::DatabaseUser_List* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser_Query,::MurmurRPC::DatabaseUser_List>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserGet() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser, ::MurmurRPC::DatabaseUser>(std::bind(&WithStreamedUnaryMethod_DatabaseUserGet<BaseClass>::StreamedDatabaseUserGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserGet(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser,::MurmurRPC::DatabaseUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserUpdate() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_DatabaseUserUpdate<BaseClass>::StreamedDatabaseUserUpdate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserUpdate(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserRegister() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser, ::MurmurRPC::DatabaseUser>(std::bind(&WithStreamedUnaryMethod_DatabaseUserRegister<BaseClass>::StreamedDatabaseUserRegister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserRegister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser,::MurmurRPC::DatabaseUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserDeregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserDeregister() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_DatabaseUserDeregister<BaseClass>::StreamedDatabaseUserDeregister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserDeregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserDeregister(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserDeregister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DatabaseUserVerify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DatabaseUserVerify() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::DatabaseUser_Verify, ::MurmurRPC::DatabaseUser>(std::bind(&WithStreamedUnaryMethod_DatabaseUserVerify<BaseClass>::StreamedDatabaseUserVerify, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DatabaseUserVerify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatabaseUserVerify(::grpc::ServerContext* context, const ::MurmurRPC::DatabaseUser_Verify* request, ::MurmurRPC::DatabaseUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDatabaseUserVerify(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::DatabaseUser_Verify,::MurmurRPC::DatabaseUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RedirectWhisperGroupAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RedirectWhisperGroupAdd() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::RedirectWhisperGroup, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_RedirectWhisperGroupAdd<BaseClass>::StreamedRedirectWhisperGroupAdd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RedirectWhisperGroupAdd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RedirectWhisperGroupAdd(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRedirectWhisperGroupAdd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::RedirectWhisperGroup,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RedirectWhisperGroupRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RedirectWhisperGroupRemove() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler< ::MurmurRPC::RedirectWhisperGroup, ::MurmurRPC::Void>(std::bind(&WithStreamedUnaryMethod_RedirectWhisperGroupRemove<BaseClass>::StreamedRedirectWhisperGroupRemove, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RedirectWhisperGroupRemove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RedirectWhisperGroupRemove(::grpc::ServerContext* context, const ::MurmurRPC::RedirectWhisperGroup* request, ::MurmurRPC::Void* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRedirectWhisperGroupRemove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MurmurRPC::RedirectWhisperGroup,::MurmurRPC::Void>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetUptime<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_ServerCreate<WithStreamedUnaryMethod_ServerQuery<WithStreamedUnaryMethod_ServerGet<WithStreamedUnaryMethod_ServerStart<WithStreamedUnaryMethod_ServerStop<WithStreamedUnaryMethod_ServerRemove<WithStreamedUnaryMethod_ContextActionAdd<WithStreamedUnaryMethod_ContextActionRemove<WithStreamedUnaryMethod_TextMessageSend<WithStreamedUnaryMethod_LogQuery<WithStreamedUnaryMethod_ConfigGet<WithStreamedUnaryMethod_ConfigGetField<WithStreamedUnaryMethod_ConfigSetField<WithStreamedUnaryMethod_ConfigGetDefault<WithStreamedUnaryMethod_ChannelQuery<WithStreamedUnaryMethod_ChannelGet<WithStreamedUnaryMethod_ChannelAdd<WithStreamedUnaryMethod_ChannelRemove<WithStreamedUnaryMethod_ChannelUpdate<WithStreamedUnaryMethod_UserQuery<WithStreamedUnaryMethod_UserGet<WithStreamedUnaryMethod_UserUpdate<WithStreamedUnaryMethod_UserKick<WithStreamedUnaryMethod_TreeQuery<WithStreamedUnaryMethod_BansGet<WithStreamedUnaryMethod_BansSet<WithStreamedUnaryMethod_ACLGet<WithStreamedUnaryMethod_ACLSet<WithStreamedUnaryMethod_ACLGetEffectivePermissions<WithStreamedUnaryMethod_ACLAddTemporaryGroup<WithStreamedUnaryMethod_ACLRemoveTemporaryGroup<WithStreamedUnaryMethod_DatabaseUserQuery<WithStreamedUnaryMethod_DatabaseUserGet<WithStreamedUnaryMethod_DatabaseUserUpdate<WithStreamedUnaryMethod_DatabaseUserRegister<WithStreamedUnaryMethod_DatabaseUserDeregister<WithStreamedUnaryMethod_DatabaseUserVerify<WithStreamedUnaryMethod_RedirectWhisperGroupAdd<WithStreamedUnaryMethod_RedirectWhisperGroupRemove<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Events() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::MurmurRPC::Void, ::MurmurRPC::Event>(std::bind(&WithSplitStreamingMethod_Events<BaseClass>::StreamedEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::MurmurRPC::Void* request, ::grpc::ServerWriter< ::MurmurRPC::Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::MurmurRPC::Void,::MurmurRPC::Event>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ServerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_ServerEvents() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler< ::MurmurRPC::Server, ::MurmurRPC::Server_Event>(std::bind(&WithSplitStreamingMethod_ServerEvents<BaseClass>::StreamedServerEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_ServerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerEvents(::grpc::ServerContext* context, const ::MurmurRPC::Server* request, ::grpc::ServerWriter< ::MurmurRPC::Server_Event>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedServerEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::MurmurRPC::Server,::MurmurRPC::Server_Event>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ContextActionEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_ContextActionEvents() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::SplitServerStreamingHandler< ::MurmurRPC::ContextAction, ::MurmurRPC::ContextAction>(std::bind(&WithSplitStreamingMethod_ContextActionEvents<BaseClass>::StreamedContextActionEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_ContextActionEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContextActionEvents(::grpc::ServerContext* context, const ::MurmurRPC::ContextAction* request, ::grpc::ServerWriter< ::MurmurRPC::ContextAction>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedContextActionEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::MurmurRPC::ContextAction,::MurmurRPC::ContextAction>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Events<WithSplitStreamingMethod_ServerEvents<WithSplitStreamingMethod_ContextActionEvents<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetUptime<WithStreamedUnaryMethod_GetVersion<WithSplitStreamingMethod_Events<WithStreamedUnaryMethod_ServerCreate<WithStreamedUnaryMethod_ServerQuery<WithStreamedUnaryMethod_ServerGet<WithStreamedUnaryMethod_ServerStart<WithStreamedUnaryMethod_ServerStop<WithStreamedUnaryMethod_ServerRemove<WithSplitStreamingMethod_ServerEvents<WithStreamedUnaryMethod_ContextActionAdd<WithStreamedUnaryMethod_ContextActionRemove<WithSplitStreamingMethod_ContextActionEvents<WithStreamedUnaryMethod_TextMessageSend<WithStreamedUnaryMethod_LogQuery<WithStreamedUnaryMethod_ConfigGet<WithStreamedUnaryMethod_ConfigGetField<WithStreamedUnaryMethod_ConfigSetField<WithStreamedUnaryMethod_ConfigGetDefault<WithStreamedUnaryMethod_ChannelQuery<WithStreamedUnaryMethod_ChannelGet<WithStreamedUnaryMethod_ChannelAdd<WithStreamedUnaryMethod_ChannelRemove<WithStreamedUnaryMethod_ChannelUpdate<WithStreamedUnaryMethod_UserQuery<WithStreamedUnaryMethod_UserGet<WithStreamedUnaryMethod_UserUpdate<WithStreamedUnaryMethod_UserKick<WithStreamedUnaryMethod_TreeQuery<WithStreamedUnaryMethod_BansGet<WithStreamedUnaryMethod_BansSet<WithStreamedUnaryMethod_ACLGet<WithStreamedUnaryMethod_ACLSet<WithStreamedUnaryMethod_ACLGetEffectivePermissions<WithStreamedUnaryMethod_ACLAddTemporaryGroup<WithStreamedUnaryMethod_ACLRemoveTemporaryGroup<WithStreamedUnaryMethod_DatabaseUserQuery<WithStreamedUnaryMethod_DatabaseUserGet<WithStreamedUnaryMethod_DatabaseUserUpdate<WithStreamedUnaryMethod_DatabaseUserRegister<WithStreamedUnaryMethod_DatabaseUserDeregister<WithStreamedUnaryMethod_DatabaseUserVerify<WithStreamedUnaryMethod_RedirectWhisperGroupAdd<WithStreamedUnaryMethod_RedirectWhisperGroupRemove<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};
//
// Meta
//

}  // namespace MurmurRPC


#endif  // GRPC_MurmurRPC_2eproto__INCLUDED
